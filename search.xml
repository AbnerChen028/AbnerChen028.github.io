<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[从crash日志得到的一些收获]]></title>
      <url>/2019/02/26/jsonmodel/</url>
      <content type="html"><![CDATA[<!-- 阐述 -->
<p>最近在公司的日志中发现一些 <code>crash</code> 信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-[__NSCFString longValue]: unrecognized selector sent to instance 0xxxxx</div><div class="line"></div><div class="line">-[__NSCFString charValue]: unrecognized selector sent to instance 0xxxxx</div></pre></td></tr></table></figure>
<p>最终确认是在使用 <code>JSONModel</code> 在由 <code>JSON</code> 转 <code>Model</code>的时候出现的问题：</p>
<!--  -->
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CPU </tag>
            
            <tag> 32位 </tag>
            
            <tag> 64位 </tag>
            
            <tag> JSONModel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[KVC中的集合运算符]]></title>
      <url>/2018/01/24/valueForKeyPath/</url>
      <content type="html"><![CDATA[<h1 id="KVC中的集合运算符"><a href="#KVC中的集合运算符" class="headerlink" title="KVC中的集合运算符"></a>KVC中的集合运算符</h1><p>当使用<code>KVC</code>中的<code>valueForKeyPath</code>方法时，可以在路径中嵌入一个集合运算。一个集合运算符前面用<code>@</code>符号开头。</p>
<h1 id="集合运算符组成"><a href="#集合运算符组成" class="headerlink" title="集合运算符组成"></a>集合运算符组成</h1><p>一个完整的集合运算符包含三个部分，如图所示：</p>
<p><img src="http://img.jessieedu.com/15166984161285.jpg" alt=""></p>
<p>一个完整的集合运算符号分三个部分：</p>
<ul>
<li>Left Key path</li>
<li>Collection operator</li>
<li>Right Key path</li>
</ul>
<p>如果要集合对象使用该方法(例如:<code>NSArray</code>)可以直接省略<code>Left Key path</code>。<code>Right Key path</code>用来制定操作的属性。除了<code>@count</code>以外的所有集合运算符都需要指定一个正确的<code>KeyPath</code>。</p>
<h1 id="集合运算符分类"><a href="#集合运算符分类" class="headerlink" title="集合运算符分类"></a>集合运算符分类</h1><p>集合运算符根据功能不同可分为三种：</p>
<h2 id="聚合运算符"><a href="#聚合运算符" class="headerlink" title="聚合运算符"></a>聚合运算符</h2><p>聚合运算符以某种方式合并一个集合中的对象，并返回一个大概匹配<code>Right Key path</code>属性的对象。当不存在<code>Right Key path</code>属性时候默认返回<code>@count</code>属性。</p>
<h2 id="数组运算符"><a href="#数组运算符" class="headerlink" title="数组运算符"></a>数组运算符</h2><p>数组运算符返回一个NSArray实例，该实例包含指定集合中的一些对象子集。</p>
<h2 id="嵌套运算符"><a href="#嵌套运算符" class="headerlink" title="嵌套运算符"></a>嵌套运算符</h2><p>嵌套运算符处理包含其他集合的集合，并根据操作符返回一个以某种方式组合嵌套集合的对象的NSArray或NSSet实例。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>首先创建一个交易对象:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Transaction</span> : <span class="title">NSObject</span></span></div><div class="line"> </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSString</span>* payee;   <span class="comment">// 收款人</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span>* amount;  <span class="comment">// 金额</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSDate</span>* date;      <span class="comment">// 日期</span></div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>一个包含多个交易对象的数组，包含以下数据:</p>
<table>
<thead>
<tr>
<th>payee</th>
<th>amount</th>
<th>date</th>
</tr>
</thead>
<tbody>
<tr>
<td>Green Power</td>
<td>$120.00</td>
<td>Dec 1, 2015</td>
</tr>
<tr>
<td>Green Power</td>
<td>$160.00</td>
<td>Jan 1, 2016</td>
</tr>
<tr>
<td>Car Loan</td>
<td>$180.00</td>
<td>Feb 1, 2016</td>
</tr>
<tr>
<td>Car Loan</td>
<td>$220.00</td>
<td>Jan 15, 2016</td>
</tr>
<tr>
<td>General Cable</td>
<td>$260.00</td>
<td>Feb 15, 2016</td>
</tr>
</tbody>
</table>
<h2 id="聚合运算"><a href="#聚合运算" class="headerlink" title="聚合运算"></a>聚合运算</h2><p>聚合运算符可以在数组或属性集上工作，产生反映集合某些方面的单个值。</p>
<h3 id="avg-平均数"><a href="#avg-平均数" class="headerlink" title="avg 平均数"></a>avg 平均数</h3><p>当指定@avg运算符时，valueForKeyPath：读取由集合中每个元素<code>Right Key path</code>指定的属性，将其转换为double（将nil值替换为0），并计算这些元素的算术平均值。 然后它返回存储在NSNumber实例中的结果。</p>
<p>具体代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSNumber</span> *avg = [transactions valueForKeyPath:<span class="string">@"@avg.amount"</span>];</div></pre></td></tr></table></figure>
<p>执行结果：<code>188</code>。</p>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>当您指定@count运算符时，valueForKeyPath：返回NSNumber实例中集合中的对象数。如果存在，<code>Right Key path</code>将被忽略。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSNumber</span> *count = [transactions valueForKeyPath:<span class="string">@"@count"</span>];</div></pre></td></tr></table></figure>
<p>执行结果： <code>5</code>。</p>
<h3 id="max-min-sum"><a href="#max-min-sum" class="headerlink" title="max / min / sum"></a>max / min / sum</h3><p>当指定@max运算符时，valueForKeyPath：在由<code>Right Key path</code>指定的属性中搜索并返回最大值，具体通过<code>compare：</code>方法对指定的属性进行排序。 因此，<code>Right Key path</code>指示的属性必须实现了<code>compare:</code>方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDate</span> *latestDate = [transactions valueForKeyPath:<span class="string">@"@max.date"</span>];</div></pre></td></tr></table></figure>
<p>此时将获取到最后一个对象的date。相同的原理还有<code>min</code>、<code>sum</code>。</p>
<h2 id="数组运算符-1"><a href="#数组运算符-1" class="headerlink" title="数组运算符"></a>数组运算符</h2><p>数组运算符计算后返回一个特定包含原数组中部分对象的数组。</p>
<h3 id="distinctUnionOfObjects"><a href="#distinctUnionOfObjects" class="headerlink" title="distinctUnionOfObjects"></a>distinctUnionOfObjects</h3><p>取出<code>Right Key path</code>中的值，并做去重处理，返回处理之后的数组：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *unionOfObjects = [transactions valueForKeyPath:<span class="string">@"@distinctUnionOfObjects.payee"</span>];</div></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">    <span class="string">"Green Power"</span>,</div><div class="line">    <span class="string">"Car Loan"</span>,</div><div class="line">    <span class="string">"General Cable"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="unionOfObjects"><a href="#unionOfObjects" class="headerlink" title="unionOfObjects"></a>unionOfObjects</h3><p>其作用与<code>distinctUnionOfObjects</code>类似，只是不会做去重处理:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *unionOfObjects = [transactions valueForKeyPath:<span class="string">@"@unionOfObjects.payee"</span>];</div></pre></td></tr></table></figure>
<p>执行结果:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">    <span class="string">"Green Power"</span>,</div><div class="line">    <span class="string">"Green Power"</span>,</div><div class="line">    <span class="string">"Car Loan"</span>,</div><div class="line">    <span class="string">"Car Loan"</span>,</div><div class="line">    <span class="string">"General Cable"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="嵌套操作符"><a href="#嵌套操作符" class="headerlink" title="嵌套操作符"></a>嵌套操作符</h2><p>嵌套操作符和数组运算符很相似，只是该操作符用于嵌套层。</p>
<p>创建<code>transactions2</code>临时数据：</p>
<table>
<thead>
<tr>
<th>payee</th>
<th>amount</th>
<th>date</th>
</tr>
</thead>
<tbody>
<tr>
<td>Green Power - 2</td>
<td>$220.00</td>
<td>Dec 1, 2015</td>
</tr>
<tr>
<td>Green Power - 2</td>
<td>$260.00</td>
<td>Jan 1, 2016</td>
</tr>
<tr>
<td>Car Loan - 2</td>
<td>$280.00</td>
<td>Feb 1, 2016</td>
</tr>
<tr>
<td>Car Loan - 2</td>
<td>$320.00</td>
<td>Jan 15, 2016</td>
</tr>
<tr>
<td>General Cable - 2</td>
<td>$360.00</td>
<td>Feb 15, 2016</td>
</tr>
</tbody>
</table>
<h3 id="distinctUnionOfArrays"><a href="#distinctUnionOfArrays" class="headerlink" title="distinctUnionOfArrays"></a>distinctUnionOfArrays</h3><p>执行以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *arrays = @[transactions, transactions2];</div><div class="line"><span class="built_in">NSArray</span> *collectedDistinctPayees = [arrays valueForKeyPath:<span class="string">@"@distinctUnionOfArrays.payee"</span>];</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">    <span class="string">"General Cable"</span>,</div><div class="line">    <span class="string">"Green Power - 2"</span>,</div><div class="line">    <span class="string">"General Cable - 2"</span>,</div><div class="line">    <span class="string">"Car Loan - 2"</span>,</div><div class="line">    <span class="string">"Green Power"</span>,</div><div class="line">    <span class="string">"Car Loan"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>单层的嵌套<code>valueForKeyPath</code>可以将所有<code>payee</code>取出并做去重处理。但是对于多层嵌套又如何那：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *arrays = @[@[transactions, transactions2], transactions];</div><div class="line"><span class="built_in">NSArray</span> *collectedDistinctPayees = [arrays valueForKeyPath:<span class="string">@"@distinctUnionOfArrays.payee"</span>];</div></pre></td></tr></table></figure>
<p>执行结果如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">    <span class="string">"General Cable"</span>,</div><div class="line">        (</div><div class="line">        <span class="string">"Green Power"</span>,</div><div class="line">        <span class="string">"Green Power"</span>,</div><div class="line">        <span class="string">"Car Loan"</span>,</div><div class="line">        <span class="string">"Car Loan"</span>,</div><div class="line">        <span class="string">"General Cable"</span></div><div class="line">        ),</div><div class="line">        (</div><div class="line">        <span class="string">"Green Power - 2"</span>,</div><div class="line">        <span class="string">"Green Power - 2"</span>,</div><div class="line">        <span class="string">"Car Loan - 2"</span>,</div><div class="line">        <span class="string">"Car Loan - 2"</span>,</div><div class="line">        <span class="string">"General Cable - 2"</span></div><div class="line">        ),</div><div class="line">    <span class="string">"Green Power"</span>,</div><div class="line">    <span class="string">"Car Loan"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>可以看出<code>valueForKeyPath</code>将数组最外层中的<code>payee</code>参数取出并做了去重处理，但是对于内层数据却没有去重。</p>
<h3 id="unionOfArrays"><a href="#unionOfArrays" class="headerlink" title="unionOfArrays"></a>unionOfArrays</h3><p>执行以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *arrays = @[transactions, transactions2];</div><div class="line"><span class="built_in">NSArray</span> *unionOfArrays = [arrays valueForKeyPath:<span class="string">@"@unionOfArrays.payee"</span>];</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">    <span class="string">"Green Power"</span>,</div><div class="line">    <span class="string">"Green Power"</span>,</div><div class="line">    <span class="string">"Car Loan"</span>,</div><div class="line">    <span class="string">"Car Loan"</span>,</div><div class="line">    <span class="string">"General Cable"</span>,</div><div class="line">    <span class="string">"Green Power - 2"</span>,</div><div class="line">    <span class="string">"Green Power - 2"</span>,</div><div class="line">    <span class="string">"Car Loan - 2"</span>,</div><div class="line">    <span class="string">"Car Loan - 2"</span>,</div><div class="line">    <span class="string">"General Cable - 2"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>该方法直接将数组中的<code>transaction</code>对象中的<code>payee</code>全部取出。</p>
<p>对于多层嵌套:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *arrays = @[@[transactions, transactions2], transactions];</div><div class="line"><span class="built_in">NSArray</span> *unionOfArrays = [arrays valueForKeyPath:<span class="string">@"@unionOfArrays.payee"</span>];</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">        (</div><div class="line">        <span class="string">"Green Power"</span>,</div><div class="line">        <span class="string">"Green Power"</span>,</div><div class="line">        <span class="string">"Car Loan"</span>,</div><div class="line">        <span class="string">"Car Loan"</span>,</div><div class="line">        <span class="string">"General Cable"</span></div><div class="line">        ),</div><div class="line">        (</div><div class="line">        <span class="string">"Green Power - 2"</span>,</div><div class="line">        <span class="string">"Green Power - 2"</span>,</div><div class="line">        <span class="string">"Car Loan - 2"</span>,</div><div class="line">        <span class="string">"Car Loan - 2"</span>,</div><div class="line">        <span class="string">"General Cable - 2"</span></div><div class="line">        ),</div><div class="line">    <span class="string">"Green Power"</span>,</div><div class="line">    <span class="string">"Green Power"</span>,</div><div class="line">    <span class="string">"Car Loan"</span>,</div><div class="line">    <span class="string">"Car Loan"</span>,</div><div class="line">    <span class="string">"General Cable"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p><code>unionOfArrays.payee</code>按照文件夹的顺序将<code>payeee</code>参数取出。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>聚合运算类可以对数据进行计算，例如平均数、总数、最大、最小计算等。其中最大最小值的获取需要属性实现<code>compare:</code>方法。 其他方法需要属性是Number型数据。</li>
<li>数组运算符中，<code>distinctUnionOfObjects</code>可以获取到数组中的对象属性全部取出并且做去重处理。假如数组两层嵌套用该方法不会将嵌套中的数据做去重处理。<code>unionOfObjects</code>只会取出数组中的数据不做去重处理。</li>
<li>嵌套操作符<code>distinctUnionOfArrays</code>可以是对<code>distinctUnionOfObjects</code>方法的一个完善。对于两层嵌套数据可以取出属性并做去重处理，对于多于两层的嵌套，内部数据将不再做去重去里。在这里<code>unionOfObjects</code>和<code>unionOfArrays</code>处理结果一致。</li>
</ul>
<p>Demo：<a href="https://github.com/AbnerChen028/ValueForKeyPath.git" target="_blank" rel="external">Github</a></p>
<p>参考：<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/CollectionOperators.html#//apple_ref/doc/uid/20002176-SW3" target="_blank" rel="external">Key-Value Coding Programming Guide</a></p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> KVC </tag>
            
            <tag> ValueForKeyPath </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS开发中的 load 和 initialize 方法]]></title>
      <url>/2017/11/02/loadinitialize/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在iOS开发中，<code>+load</code> 和 <code>+initialize</code>两个方法比较特殊。在iOS中其运行期间提前并切自动调用，而对于类方法有着不同的处理。</p>
<h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><p>根据<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418815-load" target="_blank" rel="external">Apple文档</a>描述，每当将类或类别所在文件被引用就会调用，实现此方法以在加载时执行特定于类的行为。比如说<code>Method Swizzling</code>。</p>
<p>该方法会被转发到那些动态加载和静态链接类和类别，但是那些类和类别必须实现这些方法。所有的<code>+load</code>方法在父类方法调用之后调用。分类中的方法在该类调用之后调用，一般对象分类方法优先级大于该类中的方法。</p>
<h2 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h2><p><a href="https://developer.apple.com/documentation/objectivec/nsobject/1418639-initialize" target="_blank" rel="external">Apple文档</a>中说明：</p>
<blockquote>
<p>Initializes the class before it receives its first message.</p>
</blockquote>
<p>当第一次调用的时候才会加载该方法。运行时发送<code>+initialize</code>给程序中的每个类，或者从类中继承的子类。父类在它们的子类之前收到这个消息。 运行时以线程安全的方式调用类的 <code>+initialize</code>。也就是说，初始化由第一个线程运行，向一个类发送一个消息，任何其他尝试向该类发送消息的线程都将被阻塞，直到<code>+initialize</code>完成。 如果子类不实现<code>+initialize</code>运行时将调用继承的实现，或者如果子类显式调用[super initialize]，则父类实现可能会被多次调用。如果你想保护该类不被多次运行，你可以按照以下方式构建你的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (void)initialize &#123;</div><div class="line">  if (self == [ClassName self]) &#123;</div><div class="line">    // ... do the initialization ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为该方法是以阻塞方式调用，所以在该方法中做尽可能少的工作。</p>
<h1 id="Load-与-Initalize-关系"><a href="#Load-与-Initalize-关系" class="headerlink" title="Load 与 Initalize 关系"></a>Load 与 Initalize 关系</h1><p>首先创建三个类：</p>
<p>Person类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Person</div><div class="line"></div><div class="line">+ (void)load&#123;</div><div class="line">    NSLog(@&quot;Person load&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)initialize&#123;</div><div class="line">    NSLog(@&quot;Person initialize&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>Father类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface Father : Person</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Father</div><div class="line"></div><div class="line">+ (void)load&#123;</div><div class="line">    NSLog(@&quot;Father load&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)initialize&#123;</div><div class="line">    NSLog(@&quot;Father initialize&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>Son类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface Son : Father</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Son</div><div class="line"></div><div class="line">+ (void)load&#123;</div><div class="line">    NSLog(@&quot;Son load&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)initialize&#123;</div><div class="line">    NSLog(@&quot;Son initialize&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我们只在<code>Xcode</code>项目中<code>import</code>这些类，而不去使用它们，运行得到结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person load</div><div class="line">Father load</div><div class="line">Son load</div></pre></td></tr></table></figure>
<p>这里像<code>Apple</code>文档里面说的那样，虽然没有直接调用。但是<code>runtime</code>触发了<code>+load</code>方法。</p>
<p>如果将<code>Son</code>类中的<code>load</code>方法修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@implementation Son</div><div class="line"></div><div class="line">+ (void)load&#123;</div><div class="line">    NSLog(@&quot;%@ load&quot;, NSStringFromClass([Son class]));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>则打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Person load</div><div class="line">Father load</div><div class="line">Person initialize</div><div class="line">Father initialize</div><div class="line">Son initialize</div><div class="line">Son load</div></pre></td></tr></table></figure>
<p>首先，<code>Son</code>的<code>load</code>的方法调用父类的<code>load</code>的方法，依次执行<code>Person</code>、<code>Father</code>的<code>load</code>，但是<code>[Son load]</code>方法触发了<code>Son</code>的<code>initialize</code>方法，并且依次调用了父类的<code>initialize</code>方法。另外从文档来看，<code>initialize</code>方法会在类第一个方法被调用之前调用，同时也说明了<code>runtime</code>对<code>+load</code>的调用不作为第一个类方法。</p>
<h1 id="Load-amp-Initialize-父类与子类的关系"><a href="#Load-amp-Initialize-父类与子类的关系" class="headerlink" title="Load &amp; Initialize 父类与子类的关系"></a>Load &amp; Initialize 父类与子类的关系</h1><p>此处，Person、Father、Son对象 继续沿用 Load 与 Initalize 关系中的对象。</p>
<h2 id="Load-父类与子类"><a href="#Load-父类与子类" class="headerlink" title="Load 父类与子类"></a>Load 父类与子类</h2><p>此处忽略<code>initialize</code>方法打印。</p>
<h3 id="创建Son类"><a href="#创建Son类" class="headerlink" title="创建Son类:"></a>创建Son类:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Son *son = [[Son alloc] init];</div></pre></td></tr></table></figure>
<p>打印结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person load</div><div class="line">Father load</div><div class="line">Son load</div></pre></td></tr></table></figure>
<p>在该方法中并没有调用父类的方法但是却执行了<code>load</code>方法，说明这里是隐式调用。</p>
<h3 id="修改Son类"><a href="#修改Son类" class="headerlink" title="修改Son类:"></a>修改Son类:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (void)load&#123;</div><div class="line">    [super load];</div><div class="line">    NSLog(@&quot;%@ load&quot;, NSStringFromClass([Son class]));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建Son类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Son *son = [[Son alloc] init];</div></pre></td></tr></table></figure>
<p>打印结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person load</div><div class="line">Father load</div><div class="line">Father load</div><div class="line">Son load</div></pre></td></tr></table></figure>
<p>在子类中显式的调用了<code>[super load]</code>方法父类<code>load</code>方法执行了两次。</p>
<h3 id="将Father类load注掉"><a href="#将Father类load注掉" class="headerlink" title="将Father类load注掉"></a>将Father类load注掉</h3><p>如果子类<code>Son</code>显式的调用了父类的<code>load</code>方法，而父类<code>Father</code>没有实现该方法，则该父类<code>Father</code>继续向上查找父类<code>Father</code>的父类<code>Person</code>，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person load</div><div class="line">Person load</div><div class="line">Son load</div></pre></td></tr></table></figure>
<h2 id="Initialize-父类与子类"><a href="#Initialize-父类与子类" class="headerlink" title="Initialize 父类与子类"></a>Initialize 父类与子类</h2><p>此处忽略<code>load</code>方法打印。</p>
<h3 id="创建Son类-1"><a href="#创建Son类-1" class="headerlink" title="创建Son类"></a>创建Son类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Son *son = [[Son alloc] init];</div></pre></td></tr></table></figure>
<p>打印结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person initialize</div><div class="line">Father initialize</div><div class="line">Son initialize</div></pre></td></tr></table></figure>
<p>在该方法中并没有调用父类的方法但是却执行了<code>initialize</code>方法，说明这里是隐式调用。此处与<code>load</code>一致。</p>
<h3 id="修改Son类-1"><a href="#修改Son类-1" class="headerlink" title="修改Son类:"></a>修改Son类:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (void)initialize&#123;</div><div class="line">    [super initialize];</div><div class="line">    NSLog(@&quot;%@ initialize&quot;, NSStringFromClass([Son class]));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建<code>Son</code>类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Son *son = [[Son alloc] init];</div></pre></td></tr></table></figure>
<p>打印结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person initialize</div><div class="line">Father initialize</div><div class="line">Father initialize</div><div class="line">Son initialize</div></pre></td></tr></table></figure>
<p>在子类中显式的调用了<code>[super initialize]</code>方法父类<code>initialize</code>方法执行了两次。此处与<code>load</code>一致。</p>
<h3 id="将Father类initialize注掉"><a href="#将Father类initialize注掉" class="headerlink" title="将Father类initialize注掉"></a>将Father类initialize注掉</h3><p>如果子类Son显式的调用了父类的<code>initialize</code>方法，而父类<code>Father</code>没有实现该方法，则该父类<code>Father</code>继续向上查找父类<code>Father</code>的父类<code>Person</code>，但是这里相比<code>load</code>方法多调用了一次<code>Person</code>类的<code>initialize</code>，：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person initialize</div><div class="line">Person initialize</div><div class="line">Person initialize</div><div class="line">Son initialize</div></pre></td></tr></table></figure>
<p>这里与<code>load</code>方法对比得出的结论与文档一致：</p>
<blockquote>
<p>The load() message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.</p>
</blockquote>
<h1 id="Load-amp-Initalize-类与类别的关系"><a href="#Load-amp-Initalize-类与类别的关系" class="headerlink" title="Load &amp; Initalize 类与类别的关系"></a>Load &amp; Initalize 类与类别的关系</h1><p>分别为类<code>Person</code>、<code>Father</code>、<code>Son</code>创建两个分类<code>test1</code>、<code>test2</code>，并且实现<code>+load</code>、<code>+initialize</code>方法。</p>
<h3 id="load方法与类别的关系"><a href="#load方法与类别的关系" class="headerlink" title="load方法与类别的关系"></a>load方法与类别的关系</h3><p><code>Complie Sources</code>排列顺序与打印结果:</p>
<p><img src="http://img.jessieedu.com/15143397037228.jpg" alt=""></p>
<p>此处结果与<code>Apple</code>文档一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">In addition:</div><div class="line"></div><div class="line">  *  A class’s +load method is called after all of its superclasses’ +load methods.</div><div class="line"></div><div class="line">  *  A category +load method is called after the class’s own +load method.</div></pre></td></tr></table></figure>
<p>先执行父类<code>load</code>方法再执行子类方法，先执行本类中的方法再执行分类中的方法。而分类中的<code>load</code>方法恰恰相反，先执行子类分类的<code>load</code>方法再执行父类的分类方法。</p>
<p>当调整<code>Complie Sources</code>里文件顺序之后：<br><img src="http://img.jessieedu.com/15143401263131.jpg" alt=""></p>
<p>发现分类中的执行顺序为最后加载的先执行。</p>
<h3 id="Initalize-类与类别的关系"><a href="#Initalize-类与类别的关系" class="headerlink" title="Initalize 类与类别的关系"></a>Initalize 类与类别的关系</h3><p><code>Complie Sources</code>排列顺序与打印结果:</p>
<p><img src="http://img.jessieedu.com/15143408478145.jpg" alt=""></p>
<p>分类中重写了<code>initalize</code>方法之后，覆盖了原方法，这一结果与普通对象方法一致，分类中的优先级高于原方法。</p>
<p>当调整<code>Complie Sources</code>里文件顺序之后：<br><img src="http://img.jessieedu.com/15143420477709.jpg" alt=""></p>
<p>排序靠下的被打印，与<code>load</code>方法保持一致。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>两个方法都不需要主动调用父类的方法。但是<code>+load</code>的方法不会在子类没有实现的情况下调用父类的该方法，而<code>+initialize</code>方法会调用。</li>
<li>两个方法都会在类方法以及对象方法之前调用，都可以在这里面做一些操作。在<code>+load</code>方法中一般实现<code>Method Swizzling</code>，<code>+initialize</code>方法一般做一些初始化全局变量等操作。</li>
<li>两个方法都遵循先调用父类、在调用子类的顺序执行。如果该类有分类，会先调用本类的<code>+load</code>方法再调用分类中的方法，多个分类情况下按照<code>Complie Sources</code>顺序从上到下依次执行。<code>+initialize</code>分类中的方法则会覆盖本类中的方法，多个分类情况下<code>Complie Sources</code>最下面的执行。</li>
<li>正常情况下，<code>+load</code>方法会在<code>main</code>函数执行之前执行，<code>+initialize</code>函数在<code>main</code>函数之后执行。但是如果在<code>+load</code>方法触发了<code>+initialize</code>方法则二者均会在<code>main</code>函数之前执行。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> load </tag>
            
            <tag> initialize </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[regix]]></title>
      <url>/2017/09/25/regix/</url>
      <content type="html"><![CDATA[<p>#正则表达式学习笔记</p>
<p><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">学习地址</a></p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>常用元字符表达</p>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td>匹配除换行符意外的任意字符</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td>匹配字幕或数字或下划线或汉字</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td>匹配字符串的结束</td>
</tr>
</tbody>
</table>
<h3 id="关键词-b"><a href="#关键词-b" class="headerlink" title="关键词 \b"></a>关键词 <code>\b</code></h3><p>该关键词代表着单词的开头或者结尾，也就是单词的分界处虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。</p>
<ul>
<li>查找一个词</li>
</ul>
<p>例如：查找<code>hi</code>关键词<br>表达式： <code>hi</code></p>
<ul>
<li>精确查找一个词，不会查询出<code>him</code>、<code>history</code>等关键词</li>
</ul>
<p>例如：精确查找<code>hi</code>关键词<br>表达式： <code>\bhi\b</code></p>
<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词 *"></a>关键词 <code>*</code></h3><ul>
<li>例如表达式：<code>\bhi\b.*\bLucy\b</code>表示<strong>先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。</strong></li>
</ul>
<h3 id="关键词-d"><a href="#关键词-d" class="headerlink" title="关键词 \d"></a>关键词 <code>\d</code></h3><p><code>\d</code>表示匹配数字（0～9），后面可以通过大括号表示长度。</p>
<ul>
<li>匹配一个表示号码的字符串<br>表达式：<code>0\d\d-\d\d\d\d\d\d\d\d</code><br>表示以0开头，后面跟两个数字，接着是一个连接符<code>-</code>，后面是8位的数字。<br>该表达式也可以使用如下表示：<code>0\d{2}-\d{8}</code></li>
</ul>
<h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p>如果要查找的字符串本身还有元字符的情况下需要用到转义，这里的转移和iOS一直，直接使用转义符<code>\</code>来实现。例如要查找<code>abc.com</code>，那么语法应该为<code>abc\.com</code>。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li><p><code>\ba\w*\b</code>:匹配以字母<code>a</code>开头的单词。 先是以字母开头，然后是任意数量的字符或者数字。</p>
</li>
<li><p><code>\d+</code>： 表示匹配一个或者多个连续的数字，这里<code>+</code>和<code>*</code>类似，不同的是<code>*</code>匹配任意次，可以为0，而<code>+</code>则匹配至少一次。</p>
</li>
<li><p><code>\b\w{6}\b</code>:匹配刚好长度为6的单词。</p>
</li>
<li><p><code>^\d{5,12}$</code>:长度介于5～12的数字</p>
</li>
</ul>
<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><p>前面已经结合元字符了解过部分表示重复的表达式了。这里做一个小总结</p>
<table>
<thead>
<tr>
<th style="text-align:left">语法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">重复零次或多次</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">重复一次或多次</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">重复零次或一次</td>
</tr>
<tr>
<td style="text-align:left">{n}</td>
<td style="text-align:left">重复n次</td>
</tr>
<tr>
<td style="text-align:left">{n,}</td>
<td style="text-align:left">重复n次或更多次</td>
</tr>
<tr>
<td style="text-align:left">{n,m}</td>
<td style="text-align:left">重复n到m次</td>
</tr>
</tbody>
</table>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>除了系统预留的字母数字字符集合的元字符，我们还可以自定义集合。例如，我们要匹配元音字母就可以如下方式表示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[aeiou]</div></pre></td></tr></table></figure>
<p>如果要匹配标点符号就可以用下面的方式表达：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[,.!]</div></pre></td></tr></table></figure>
<p>也可以制定一个符号的范围：<code>[0-9]</code>代表的含义等同于<code>\d</code><br><code>[a-z0-9A-Z]</code>也等用于<code>\w</code></p>
<p>复杂表达式解读：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\(?0\d&#123;2&#125;[) -]?\d&#123;8&#125;</div></pre></td></tr></table></figure>
<p>首先，开头转义符<code>\</code>,<code>?</code>表示可能出现零次或者一次，也就是说<code>(</code>符号可能出现。后面是字符<code>0</code>。接着是两位数字。后面是一个集合<code>[)-]</code>，但是后面的<code>?</code>表示有可能出现，最后是8位数字。这样可以匹配到的数据格式如下:</p>
<ul>
<li>(010)12345678</li>
<li>010-12345678</li>
<li>01012345678</li>
</ul>
<h2 id="分支条件"><a href="#分支条件" class="headerlink" title="分支条件"></a>分支条件</h2><p>在我们正常的编程中存在if … else 和 switch 语法来匹配不同条件下的实现，在正则中也存在分支编程。在字符类中，复杂表达式的解读中会存在一个问题，就是该正则表达式会匹配到<code>0102345678</code> 或者 <code>010-12345678</code>这类的不正确格式。为防止此类问题的出现我们就可以通过分支语法来实现。</p>
<ul>
<li><code>0\d{2}-\d{8}|0\d{3}-\d{7}</code>:表示可以匹配<code>010-12345678</code>，也可以匹配<code>0123-1234567</code>类型的数据。</li>
<li><code>\(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8}</code>：该语法是对第三部分表达式的完善。</li>
</ul>
<p>注意：使用分支语法的时候，从左到右，匹配到某个分支之后，后面的分支不在匹配。</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>例如要匹配一个IP地址，简单的我们可以通过以下表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;</div></pre></td></tr></table></figure>
<p>这个表达式可以匹配出一个IP地址。但是，也可能匹配出<code>123.234.345.456</code>这类非正确IP地址来，也会将<code>1.2.3.4</code>这类的IP给遗漏，这里我们就需要使用分组来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)</div></pre></td></tr></table></figure>
<p>下面来解读该语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(2[0-4]\d|25[0-5]|[01]?\d\d?)\.</div></pre></td></tr></table></figure>
<p>首先，该语句为三个分支：</p>
<ul>
<li>开头为<code>2</code>的情况下，第二位可以为<code>0～4</code>，第三位随意。</li>
<li>开头为<code>25</code>的情况下，地三位可以为<code>0～5</code>。</li>
<li>开头为 <code>0</code>或<code>1</code>的情，第二位随意，第三位可选。或者第一位是空，第二位<code>0~9</code>,第三位为空。</li>
</ul>
<p>这样，这个数字就被限定在了<code>0~255</code>之间。然后循环三次，再添加一位不带<code>.</code>，就能保证匹配出来的IP是正确的。</p>
<h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><p>在查询不属于某个能简单定义的字符类的字符的时候，比如要想查询除了数字意外的语句，就能用到反义了。</p>
<p>常见的反义代码</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\W</td>
<td>匹配任意不是字母、数字、下划线、汉字的字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意不是空白字符的字符</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td>\B</td>
<td>匹配除了单词开头或结束的位置</td>
</tr>
<tr>
<td>[\^x]</td>
<td>匹配除x以外的任意字符 <strong>备注</strong></td>
</tr>
<tr>
<td>[\^aeiou]</td>
<td>匹配除了aeiou以外的任意字符 <strong>备注</strong></td>
</tr>
</tbody>
</table>
<p><strong>备注</strong>：在使用的时候请去掉<code>\</code>，因为在<code>markdown</code>下会被默认解析为 [^x]</p>
<h2 id="正则表达式在iOS开发中应用"><a href="#正则表达式在iOS开发中应用" class="headerlink" title="正则表达式在iOS开发中应用"></a>正则表达式在iOS开发中应用</h2><ul>
<li>验证数据的有效性</li>
</ul>
<p>例如在iOS中，要检测用户注册输入的密码是否满足需求：<br>当前要求用户输入的密码包含数组和字母组合，长度为6～18位：</p>
<p>首先为NSString写一个分类方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)validataForPWD&#123;</div><div class="line">    NSString *regxp = @&quot;^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;6,18&#125;$&quot;;</div><div class="line">    NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,regxp];</div><div class="line">    return [predicate evaluateWithObject:self];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用的时候使用下方法调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL result = [@&quot;cwtest123&quot; validataForPWD]</div></pre></td></tr></table></figure>
<ul>
<li><p>批量修改代码：<br>如果代码中需要批量修改的地方，可以借助<code>Xcode</code>中的查找查找替换功能完成：<br>例如，</p>
</li>
<li><p><del>数据筛选(iOS中为谓词)</del><br>一个数组peronArray中存储这多个<code>Person</code>对象，每一个<code>Person</code>对象有个年龄属性。<br>现在要筛选出年龄大于30的对象：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;self.age &gt; 30&quot;];</div><div class="line">NSArray *result = [personArray filteredArrayUsingPredicate:pre];</div></pre></td></tr></table></figure>
<p>result中存储的即为年龄大于30的对象。</p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Apple审核中的服务器IPv6解决]]></title>
      <url>/2017/07/10/iOSIPv6/</url>
      <content type="html"><![CDATA[<p>苹果早在在2016年6月1号的时候支持<code>IPv6</code>，当时将<code>App</code>里面的第三方SDK升级了一下，然后在本地搭建了一个<code>IPv6</code>环境进行测试了一下没问题就认为OK了，直到最近提交市场审核才意识到没那么简单。搞了一个周，前两天项目顺利上线，遂记录下整个流程以备使用。这里不在阐述<code>iOS</code>端的<code>IPv6</code>的兼容，主要是服务器的兼容。</p>
<p>目前服务器兼容<code>IPv6</code>大概有三种方法：</p>
<ul>
<li>服务器配置真实<code>IPv6</code>地址；</li>
<li>通过<code>IPv6</code>隧道来实现<code>IPv6</code>的访问。可参考<a href="http://www.jianshu.com/p/6de46c07f040" target="_blank" rel="external">博客</a>；</li>
<li>通过带有<code>IPv6</code>地址的服务器做一个代理，将数据转移到自己真实的服务器上。</li>
</ul>
<p>由于国内的网络环境，使用第一种方式显得不切实际。第二种方式基本上都是使用的<code>HE</code>隧道来搭建，免费便捷，但是需要服务器去配合。我们自己使用的是第三种方式，所有的东西都是自己的，用着比较放心。实现的思路是购买一个带有<code>IPv6</code>的<code>VPS</code>，通过<code>nginx</code>代理将<code>VPS</code>上的数据解析到真实的<code>IPv4</code>服务器上，以满足<code>Apple</code>审核的要求。</p>
<h1 id="服务器设置"><a href="#服务器设置" class="headerlink" title="服务器设置"></a>服务器设置</h1><h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><p>第一步购买一个带有<code>IPv6</code>地址的<code>VPS</code>，我选择的是搬瓦工<code>VPS</code>，推荐<a href="https://bwh1.net/cart.php?a=confproduct&amp;i=2" target="_blank" rel="external">配置</a>，购买时候务必看清是否支持<code>IPv6</code>：<br><img src="http://img.jessieedu.com/14998316138233.jpg" alt=""><br>然后选择购买的时长和服务器位置，最后点击加入购物车。然后进入购物车，在支付之前可以到网上搜索一下优惠码，还能优惠6%左右。</p>
<h2 id="添加IPv6"><a href="#添加IPv6" class="headerlink" title="添加IPv6"></a>添加<code>IPv6</code></h2><p>购买之后选择在首页选择<code>Client Area</code> -&gt; <code>Services</code> -&gt; <code>My Services</code>，可以看到自己购买的额服务器，然后点击<code>Kiwivm Control Panel</code>，进入管理界面。选择<code>IPv6 Addresses</code>：<br><img src="http://img.jessieedu.com/14998402174133.jpg" alt=""><br>然后根据提示添加<code>IPv6</code>即可。</p>
<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装<code>nginx</code></h2><p>控制面板自带的<code>Shell</code>用着相当费劲，不建议使用。强烈推荐使用<code>iTerm</code>或者<code>Terminal</code>。<code>ssh</code>登录账号密码以及端口号在<code>Main controls</code>中查看。<br><code>nginx</code>以<code>1.7.4</code>版本为例。</p>
<p>首先安装变异工具以及库文件，<code>VPS</code>默认不带这些配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install gcc gcc-c++  pcre-devel  openssl-devel</div></pre></td></tr></table></figure>
<p>下载<code>nginx</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://nginx.org/download/nginx-1.7.4.tar.gz</div></pre></td></tr></table></figure>
<p>解压文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar zxvf nginx-1.7.4.tar.gz</div></pre></td></tr></table></figure>
<p>进入安装包目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd  nginx-1.7.4</div></pre></td></tr></table></figure>
<p>编译nginx：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-ipv6</div></pre></td></tr></table></figure>
<p>安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<p>安装完毕之后通过命令查看版本号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/nginx/sbin/nginx -v</div></pre></td></tr></table></figure>
<p>如图所示，表示安装成功<br><img src="http://img.jessieedu.com/14998438446371.jpg" alt=""></p>
<p>通过你的IP地址访问：<br><img src="http://img.jessieedu.com/14998439691945.jpg" alt=""></p>
<h2 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h2><p>进入配置文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/nginx/conf</div></pre></td></tr></table></figure>
<p>打开配置文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi nginx.conf</div></pre></td></tr></table></figure>
<p>配置如下：<br><img src="http://img.jessieedu.com/14998449552219.jpg" alt=""><br>其中，第一个为自己<code>VPS</code>的<code>IPv6</code>，第二个为<code>VPS</code>的<code>IPv4</code>，当然也可以只配置<code>IPv6</code>。都配置的话方便验证配置，此时通过<code>IPv4</code>访问效果：<br><img src="http://img.jessieedu.com/14998454036652.jpg" alt=""><br>显示不再是<code>nginx</code>的欢迎界面，说明此时已经转移到自己的真实服务器上了。（我们公司服务器使用的<code>windows</code>的<code>IIS</code>，根据自己公司的实际情况会有不同的提示）</p>
<p><code>location</code>里面的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">      proxy_pass http://国内真实服务器IPv4地址:80;</div><div class="line">      proxy_set_header HOST $host;</div><div class="line">      proxy_set_header X-Real-IP $remote_addr;</div><div class="line">      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里只是配置的是<code>http</code>，如果项目中使用了<code>https</code>，可以在下面https配置中添加同样的配置即可。</p>
<h1 id="添加一个AAAA解析"><a href="#添加一个AAAA解析" class="headerlink" title="添加一个AAAA解析"></a>添加一个AAAA解析</h1><p>最后一步是为项目域名添加一个<code>AAAA</code>解析，地址为<code>VPS</code>的<code>IPv6</code>地址。然后通过<a href="http://ipv6-test.com/validate.php" target="_blank" rel="external">IPv6测试</a>进行<code>IPv6</code>兼容性测试，效果如下：<br><img src="http://img.jessieedu.com/14998466475702.jpg" alt=""><br>说明已经通过测试，此时说明服务器完成了<code>IPv6</code>的兼容。</p>
<h1 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h1><p><code>IPv6</code>的兼容需要从两个方面去处理，首要的就是<code>App</code>端，如果不涉及底层网络的话只要保证使用的SDK为新版本基本没有问题，至于相容性都可以在其官网上查询到。另外，一块就是服务器的兼容。由于<code>VPS</code>基本集中在美国，在网络环境上会有一个延迟，由于我们的项目中使用了大量的H5和原生交互的地方，导致加载Web的超时被拒。我们的做法就是在提交审核的时候进行一个简单的说明。如果允许的话还是建议购买中国周边的服务器来做中转。</p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Apple审核 </tag>
            
            <tag> IPv6 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS端HTTPS中间人攻击]]></title>
      <url>/2017/05/23/https/</url>
      <content type="html"><![CDATA[<p>通过HTTPS方式在客户端和服务器进行交互的过程，原理如图：<br><img src="http://img.jessieedu.com/publicKeyCrytography.png" alt="publicKeyCrytography"><br>（图片来自网络）</p>
<p>此处，Alice表示<code>Client</code>端，Bob表示<code>Server</code>端。首先服务器端用非对称加密（RSA）产生公钥和私钥。然后把公钥发给客户端，路径或许有人会截取，但是没有用，因为用公钥加密的文件只有私钥可以解密，而私钥永远都不会离开服务器的。当公钥到达客户端之后，客户端会用对称加密产生一个秘钥并且用公钥来加密发送给服务器端，这个秘钥就是以后用来通信的钥匙。这样服务器端收到公钥加密的秘钥时就可以用私钥来解公钥从而获得秘钥。这样的话客户端和服务器端都获得了秘钥，信息交流相对是安全的。</p>
<p>所谓的中间人攻击，证的过程中，出现了一个“中间人”拦截我们的信息，他有意想要知道你们的消息。我们将这个中间人称为Mallory。当服务器第一次给客户端发送公钥的时候，途径Mallory。Mallory知道你要进行密钥交换了，它把公钥扣了下来，假装自己是客户端，伪造了一个伪秘钥（对称加密产生的），然后用服务器发来的公钥加密了伪秘钥发还给服务器，这样服务器以为和客户端完成了密钥交换，实际上服务器是和Mallory完成了密钥交换（获得了伪秘钥）。同时Mallory假扮成服务器自行用非对称加密产生伪公钥和伪私钥，与客户端进行秘钥交换，拿到客户端发送过来的秘钥。现在客户端拿着秘钥，M拿着秘钥和为伪秘钥，服务器拿着伪秘钥，详细过程如图所示：<br><img src="http://img.jessieedu.com/man-in-the-middleAttack.png" alt="man-in-the-middleAttack"><br>（图片来自网络）</p>
<p>目前各类网络工具去抓取分析数据的原理基本均是采用中间人攻击的方法来实现。下图为使用<code>Charles</code>抓取汽车之家<code>HTTPS</code>接口数据数据：<br><img src="http://img.jessieedu.com/14981030708039.jpg" alt=""></p>
<p>对于iOS开发者角度，防止中间人攻击可以从两个方面着手：</p>
<p>第一是通讯内容本身加密，无论是走<code>http</code>还是<code>https</code>，<code>request</code>和<code>response</code>的内容本身都要先做一次加密，这样即使<code>https</code>的流量被破解，攻击者还需要再攻破一层加密算法。我们一般使用 <code>AES256</code> 对内容做加密，这里<code>AES</code>密钥的管理也有两种方式，其一是在客户端使用固定的密钥，为了加大破解的难度，我们可以对密钥本身做多次加密处理，使用时再在内存里解密出来真正的密钥。其二是每次会话都使用不同的密钥，原理类似 <code>Forward Secrecy</code>，即使流量被记录，将来被暴力破解，也能极大的增加攻击者破解的时间成本。如果为<code>Apple</code>的一个接口：<br><img src="http://img.jessieedu.com/14981109907155.jpg" alt=""></p>
<p>第二种就是大家所熟知的 ssl pinning。在客户端进行代码层面的证书校验，校验方式也有两种，一是证书本身校验，而是公钥校验。这两种方式对应到 AFNetworking 中的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum &#123;</div><div class="line">     AFSSLPinningModeNone,</div><div class="line">     AFSSLPinningModePublicKey,</div><div class="line">     AFSSLPinningModeCertificate,</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>证书校验是文件级别的校验，客户端只信任若干个证书文件，这些证书文件是和客户端一起打包发布的，这种处理方式要面对的一个问题证书过期问题，为了避免证书过期导致的校验失败，客户端和服务器之间需要额外存在一个证书更新机制，其实做起来也比较简单，只需要服务器下发一个特定的错误码，触发一个客户端的新证书下载流程即可。</p>
<p>公钥校验模式可以免去上述的麻烦，公钥模式只校验证书中所包含的公钥是否匹配，即使证书过期了，只要服务器更新证书，保证公钥不变，依然能完成校验过程，但这个大前提是，服务器的公钥私钥对不能更换。</p>
<p>比如，有些客户端做了<code>httpdns</code>，<code>http</code>请求里是<code>IP</code>地址而非域名，这样自然无法通过证书校验环节中的域名匹配，这种时候，我们需要干预证书校验的环节，比如<code>AFNetworking</code>允许我们设置<code>validatesDomainName</code>，<code>NSURLSession</code>也提供如下方法让我们对证书校验过程做一些特殊处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential *))completionHandler;</div></pre></td></tr></table></figure>
<p>目前在我们项目中，采用的是第一种方案，将参数根据时间戳来加密字段，使所有字段均为不可见的状态。如果抛开<code>HTTPS</code>，在项目中数据传递也必须进行相应的保护机制，对数据进行加密或者验证是必不可少的一步。</p>
<p>参考资料：<br><a href="https://zhuanlan.zhihu.com/p/26916851" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/26916851</a><br><a href="http://www.jianshu.com/p/56fc18937d09" target="_blank" rel="external">http://www.jianshu.com/p/56fc18937d09</a></p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> https </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用symbolicatecrash分析crash文件]]></title>
      <url>/2017/03/26/symbolicatecrash/</url>
      <content type="html"><![CDATA[<p><code>symbolicatecrash</code>是Xcode自带的一个崩溃文件分析工具。在Xcode8中，可以在一下路径获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash</div></pre></td></tr></table></figure>
<p>在<code>Xcode8</code>之前的位置在终端中使用<code>find</code>命令获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find /Applications/Xcode.app -name symbolicatecrash -type f</div></pre></td></tr></table></figure>
<p>获取到<code>symbolicatecrash</code>之后将创建一个文件夹，将你要分析的<code>.crash</code>文件<br>、打包时候导出的<code>.dSYM</code>文件以及<code>symbolicatecrash</code>放进去。如果发现发现<code>.dSYM</code>没有生成，可以通过以下方法设置：选择项目-&gt; 目标<code>Target</code>-&gt; <code>Build Settings</code> 搜索 <code>dsym</code> ，将<code>Debug Information Format</code> 选项设置为 <code>DWARF with dSYM File</code>。</p>
<p>接下来分析<code>crash</code>文件。</p>
<ul>
<li>终端进入刚刚创建的文件夹，执行命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./symbolicatecrash 文件名.crash 文件名.dSYM &gt; OutSymbol.crash</div></pre></td></tr></table></figure>
<ul>
<li>如果此时终端提示如下错误：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69.</div></pre></td></tr></table></figure>
<p>可以通过以下命令解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export DEVELOPER_DIR=&quot;/Applications/XCode.app/Contents/Developer&quot;</div></pre></td></tr></table></figure>
<p>此时分析结果就保存在该文件夹下面的<code>OutSymbol.crash</code>中了。</p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> symbolicatecrash </tag>
            
            <tag> crash </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CentOS安装GitLab记录]]></title>
      <url>/2017/01/23/gitlab/</url>
      <content type="html"><![CDATA[<h1 id="服务器快速搭建"><a href="#服务器快速搭建" class="headerlink" title="服务器快速搭建"></a>服务器快速搭建</h1><p>服务器是CentOS的mini版本，可以参考gitlab中文社区的教程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://www.gitlab.com.cn/installation/#centos-7</div></pre></td></tr></table></figure>
<h2 id="安装并配置必要的依赖关系"><a href="#安装并配置必要的依赖关系" class="headerlink" title="安装并配置必要的依赖关系"></a>安装并配置必要的依赖关系</h2><p>添加依赖，在CentOS7下，以下命令还将在系统防火墙中打开HTTP和SSH访问:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo yum install -y curl policycoreutils-python openssh-server openssh-clients</div><div class="line">sudo systemctl enable sshd</div><div class="line">sudo systemctl start sshd</div><div class="line">    </div><div class="line">sudo firewall-cmd --permanent --add-service=http</div><div class="line">sudo systemctl reload firewalld</div></pre></td></tr></table></figure>
<p>安装Postfix邮件服务。如果你不使用Postfix服务的话，请跳过此步骤并在安装完GitLab后配置外部SMTP服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo yum install postfix</div><div class="line">sudo systemctl enable postfix</div><div class="line">sudo systemctl start postfix</div></pre></td></tr></table></figure>
<p>在Postfix安装期间，可能会出现一个配置选项。选择“Internet站点”并按回车。使用您的服务器的外部DNS’邮件名称’，然后按回车。如果出现其他选项，请继续按回车键以接受默认值。</p>
<h2 id="安装GitLab软件包"><a href="#安装GitLab软件包" class="headerlink" title="安装GitLab软件包"></a>安装GitLab软件包</h2><p>下载GitLab安装脚本，官网给的安装为<code>ee</code>版本，此处换成<code>ce</code>版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash</div></pre></td></tr></table></figure>
<p>如果系统使用了代理软件，这里有可能会有如下错误，可以暂时先退出软件即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl: (6) Could not resolve host: packages.gitlab.com; 未知的错误</div></pre></td></tr></table></figure>
<p>安装GitLab软件包。将<code>http：// gitlab.example.com</code>更改为您要访问您的GitLab实例的URL。安装将自动配置并启动该URL的GitLab。这里如果是内网的话建议直接给IP地址，或者映射一个域名地址。这一步需要从网上下载安装包，时间较长，耐心等待一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo EXTERNAL_URL=&quot;http://192.168.10.6&quot; yum install -y gitlab-ce</div></pre></td></tr></table></figure>
<p>安装完毕：<br><img src="http://img.jessieedu.com/15151453149949.jpg" alt=""></p>
<p>到此，就表示安装完毕了。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul>
<li>如果发现无法在其他地址无法打开，可以先检查防火墙。</li>
<li>打开地址，首先配置<code>root</code>账号密码。其他配置请参考<a href="https://docs.gitlab.com/omnibus/README.html#installation-and-configuration-using-omnibus-package" target="_blank" rel="external">GitLab文档</a>。</li>
<li>为了后期产生不必要的麻烦，将服务器的IP地址固定。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[appledoc]]></title>
      <url>/2016/12/25/appledoc/</url>
      <content type="html"><![CDATA[<h1 id="使用appledoc生成文档"><a href="#使用appledoc生成文档" class="headerlink" title="使用appledoc生成文档"></a>使用appledoc生成文档</h1><p><a href="https://github.com/tomaz/appledoc" target="_blank" rel="external">appledoc</a>可以生成和苹果文档一样体验的文档。在项目开发中比较实用。</p>
<h2 id="使用篇"><a href="#使用篇" class="headerlink" title="使用篇"></a>使用篇</h2><p>首先是安装，通过终端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git clone git://github.com/tomaz/appledoc.git</div><div class="line">cd ./appledoc</div></pre></td></tr></table></figure>
<p>在这里不建议直接通过一下方式安装，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo sh install-appledoc.sh</div></pre></td></tr></table></figure>
<p>首先通过<code>Xcode</code>打开项目，依次选择：<code>Classes</code>-&gt;<code>Store</code>-&gt;<code>GBMethodData</code>，注释掉第44行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSParameterAssert([arguments count] &gt;= 1);</div></pre></td></tr></table></figure>
<p>在我们书写注释的时候可能不会完全按照标准书写，这样不会在使用<code>appledoc</code>生成的文档的过程中不会因为该断言而失败。注释之后可以通过Xcode运行安装该软件也可以通过<code>sh</code>脚本安装。安装完毕之后，可以通过一下命令验证是否成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appledoc --version</div></pre></td></tr></table></figure>
<p>其次是使用，最便捷的方法方法是通过终端进入到项目所在的文件夹，执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appledoc --project-name 项目名 --project-company 公司名 ./</div></pre></td></tr></table></figure>
<p>将“项目名”和“公司名”更换成实际的项目名和公司名即可。生成的文档位于以下路径：<br>/Users/YourUserName/Library/Developer/Shared/Documentation/DocSets/</p>
<p>该路径也是苹果文档所在文件夹。结合<a href="http://www.sdifenzhou.com/dash331.html" target="_blank" rel="external">Dash</a>使用效果还是不错，如图：<br><img src="http://img.jessieedu.com/15142021771020.jpg" alt=""></p>
<p>如果我们也可以从DocSet中提取出Web版式的文档，如图：<br><img src="http://img.jessieedu.com/15142021935236.jpg" alt=""></p>
<p>要添加更多参数可以使用以下命令进行分页查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appledoc --help | more</div></pre></td></tr></table></figure>
<p>当然，我们也可以将集成在Xcode中，在项目中添加一个targer，选择一个<code>Aggregate</code>模版，点击<code>Add Build Phase</code>按钮，添加一个<code>Run Script</code>，在此处添加一个自动化脚本，然后编译项目，即可自动安装进Xcode。脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">company=&quot;公司名&quot;;</div><div class="line">outputPath=&quot;~/User/&quot;; // 文档输出路径</div><div class="line">/usr/local/bin/appledoc \</div><div class="line">--project-name &quot;$&#123;PROJECT_NAME&#125;&quot; \</div><div class="line">--project-company &quot;$&#123;company&#125;&quot; \</div><div class="line">--output &quot;$&#123;outputPath&#125;&quot; \</div><div class="line">--publish-docset \</div><div class="line">--logformat xcode \</div><div class="line">--keep-intermediate-files \</div><div class="line">--no-repeat-first-par \</div><div class="line">--no-warn-invalid-crossref \</div><div class="line">--exit-threshold 2 \</div><div class="line">&quot;$&#123;PROJECT_DIR&#125;&quot;</div></pre></td></tr></table></figure>
<h2 id="语法篇"><a href="#语法篇" class="headerlink" title="语法篇"></a>语法篇</h2><p>目前，Xcode8由于是不支持插件的，但是在之前我们习惯于使用<a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="external">VVDocumenter</a>来生成注释，现在我们可以通过 <code>cmd</code>+<code>opt</code>+<code>/</code> 来快速生成。</p>
<p>在使用中，我们必须遵守一定的语法才能被正确识别。以下注释均可被识别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/// 界面已经显示出来</div><div class="line">- (void)viewDidAppear:(BOOL)animated;</div><div class="line"></div><div class="line">/**</div><div class="line">界面已经显示出来</div><div class="line">*/</div><div class="line">- (void)viewDidAppear:(BOOL)animated;</div><div class="line"></div><div class="line">/*!</div><div class="line">界面已经显示出来</div><div class="line">*/</div><div class="line">- (void)viewDidAppear:(BOOL)animated</div></pre></td></tr></table></figure>
<p>同时，<code>appledoc</code>也支持<code>MarkDown</code>语法，在此不再详细介绍。<br>另外，我们也使用以下关键字可以使我们写出来的文档更加详细：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">@brief 这里是方法的简介。该Tag不能放到类注释里。</div><div class="line">@exception &lt;#Object#&gt; 这里是方法抛出异常的说明</div><div class="line">@see &lt;#Object#&gt; 这里相当于一个应用</div><div class="line">@warning 这里是警告，会显示成蓝色的框框</div><div class="line">@bug 这里是bug，会显示成黄色的框框</div><div class="line">@param &lt;#param#&gt; 这里是参数说明</div><div class="line">@return 这里是返回值说明</div><div class="line"></div><div class="line">///---------------------------</div><div class="line">/// @name test</div><div class="line">///---------------------------</div><div class="line">上面这种书写方式相当于 #pragma mark test，但是pragma在appledoc中是无效的。</div><div class="line"></div><div class="line">*/</div></pre></td></tr></table></figure>
<p>有了<code>appledoc</code>，相信我们每个人都能写出一个好的文档，是我们团队开发中的一个利器。</p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文档 </tag>
            
            <tag> doc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编译报错记录]]></title>
      <url>/2016/12/14/compileerror/</url>
      <content type="html"><![CDATA[<p>今天接手一个新项目，由于使用的<code>CocoaPods</code>来管理第三方的，使用<code>pod install</code>命令之后打开项目发现如下警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ld: warning: directory not found for option &apos;-L/Users/abnerchen/Library/Developer/Xcode/DerivedData/PioneerSalesApp-cvhvopmhxlvwrhazdwjzrhpbbwkd/Build/Products/Debug-iphonesimulator/AFNetworking&apos;</div><div class="line">ld: warning: directory not found for option &apos;-L/Users/abnerchen/Library/Developer/Xcode/DerivedData/PioneerSalesApp-cvhvopmhxlvwrhazdwjzrhpbbwkd/Build/Products/Debug-iphonesimulator/FMDB&apos;</div><div class="line">ld: warning: directory not found for option &apos;-L/Users/abnerchen/Library/Developer/Xcode/DerivedData/PioneerSalesApp-cvhvopmhxlvwrhazdwjzrhpbbwkd/Build/Products/Debug-iphonesimulator/MBProgressHUD&apos;</div><div class="line">ld: warning: directory not found for option &apos;-L/Users/abnerchen/Library/Developer/Xcode/DerivedData/PioneerSalesApp-cvhvopmhxlvwrhazdwjzrhpbbwkd/Build/Products/Debug-iphonesimulator/PBKDF2-Wrapper&apos;</div><div class="line">ld: warning: directory not found for option &apos;-L/Users/abnerchen/Library/Developer/Xcode/DerivedData/PioneerSalesApp-cvhvopmhxlvwrhazdwjzrhpbbwkd/Build/Products/Debug-iphonesimulator/Reachability&apos;</div><div class="line">ld: warning: directory not found for option &apos;-L/Users/abnerchen/Library/Developer/Xcode/DerivedData/PioneerSalesApp-cvhvopmhxlvwrhazdwjzrhpbbwkd/Build/Products/Debug-iphonesimulator/SBJson&apos;</div><div class="line">ld: warning: directory not found for option &apos;-L/Users/abnerchen/Library/Developer/Xcode/DerivedData/PioneerSalesApp-cvhvopmhxlvwrhazdwjzrhpbbwkd/Build/Products/Debug-iphonesimulator/SFHFKeychainUtils&apos;</div><div class="line">ld: warning: directory not found for option &apos;-L/Users/abnerchen/Library/Developer/Xcode/DerivedData/PioneerSalesApp-cvhvopmhxlvwrhazdwjzrhpbbwkd/Build/Products/Debug-iphonesimulator/SQLCipher&apos;</div><div class="line">ld: warning: directory not found for option &apos;-L/Users/abnerchen/Library/Developer/Xcode/DerivedData/PioneerSalesApp-cvhvopmhxlvwrhazdwjzrhpbbwkd/Build/Products/Debug-iphonesimulator/Toast&apos;</div><div class="line">ld: library not found for -lAFNetworking</div><div class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</div></pre></td></tr></table></figure>
<p>在网上查找了一番，在<a href="http://stackoverflow.com/questions/27055970/xcode-6-1-file-was-built-for-x86-64-which-is-not-the-architecture-being-linked" target="_blank" rel="external">stackoverflow</a>找到一个方法：<br><strong>Make sure you have i386 and x86_64 listed in your Architectures in Build settings for your lib. Also set Build Active Architecture Only explicitly to No.</strong> </p>
<p>但是我发现其实项目中<code>Valid architectures</code>只有 <code>arm64</code> <code>armv7</code> <code>armv7s</code>，也就是说即将编译的指令集中不包含有<code>x86</code>的指令，此时的<code>Build Active Architecture Only</code>参数为<code>NO</code>,此时编译生成的指令是不能够在<code>x86</code>的机器上使用的。然后将<code>Build Active Architecture Only</code>参数设置为<code>DEBUG</code>模式下设为<code>YES</code>，<code>RELEASE</code>设为<code>NO</code>，再次运行，完美解决。</p>
<p>另一个错误如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">duplicate symbol _approvalFlag in:</div><div class="line">/Users/abnerchen/Library/Developer/Xcode/DerivedData/PioneerSalesApp-cvhvopmhxlvwrhazdwjzrhpbbwkd/Build/Intermediates/PioneerSalesApp.build/Debug-iphonesimulator/PioneerSalesApp.build/Objects-normal/x86_64/SearchController.o</div><div class="line">/Users/abnerchen/Library/Developer/Xcode/DerivedData/PioneerSalesApp-cvhvopmhxlvwrhazdwjzrhpbbwkd/Build/Intermediates/PioneerSalesApp.build/Debug-iphonesimulator/PioneerSalesApp.build/Objects-normal/x86_64/ChildChannelView.o</div><div class="line">ld: 1 duplicate symbol for architecture x86_64</div><div class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</div></pre></td></tr></table></figure>
<p>该问题在<a href="http://stackoverflow.com/questions/11233235/what-is-gcc-no-common-blocks-used-for" target="_blank" rel="external">stackoverflow</a>的解决办法如下：<code>Target</code>-&gt;<code>Build Settings</code>-&gt;<code>Apple LLVM -Code Generation</code>-&gt;<code>No Common Blocks</code> 设置为<code>NO</code>。</p>
<p>该问题在<code>Apple</code>的官方文档描述：</p>
<blockquote>
<p>In C, allocate even uninitialized global variables in the data section of the object file, rather than generating them as common blocks. This has the effect that if the same variable is declared (without extern ) in two different compilations, you will get an error when you link them. The only reason this might be useful is if you wish to verify that the program will work on other systems which always work this way.  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编译 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[android布局]]></title>
      <url>/2016/10/29/androidlayout/</url>
      <content type="html"><![CDATA[<p>最近在学习<code>android</code>开发，<code>android</code>中的布局相对于<code>iOS</code>中的布局比较简单，和<code>H5</code>中的布局比较相似，以下为学习笔记。</p>
<h1 id="线性布局-LinearLayout"><a href="#线性布局-LinearLayout" class="headerlink" title="线性布局 LinearLayout"></a>线性布局 LinearLayout</h1><p>子控件水平布局或者垂直布局，可以通过<code>orientation</code>参数设置水平或者垂直分布。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">orientation = vertical // 垂直</div><div class="line">= horizontal // 水平</div></pre></td></tr></table></figure>
<p><code>gravity</code>设置子类的xy的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">center //居中</div><div class="line">center_vertical // Y轴居中</div><div class="line">center_ horizontal // X轴居中</div><div class="line">right / left / bottom // 子类控件卫浴当前布局的右侧/左侧/底部</div></pre></td></tr></table></figure>
<p><code>layout_gravity</code> 自身在父容器的XY位置</p>
<p><code>layout_weight</code> 自身在父容器占的比例。 水平方向和垂直方向相反</p>
<h1 id="相对布局-RelativeLayout"><a href="#相对布局-RelativeLayout" class="headerlink" title="相对布局 RelativeLayout"></a>相对布局 RelativeLayout</h1><h2 id="相对父容器的一个位置："><a href="#相对父容器的一个位置：" class="headerlink" title="相对父容器的一个位置："></a>相对父容器的一个位置：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">layout_alignParentLeft = &quot;true&quot; // 子类控件想对当前父容器靠左边</div><div class="line">layout_alignParentTop = &quot;true&quot; // 上边</div><div class="line">layout_marginLeft = &quot;41dp&quot; 左边距离</div><div class="line">layout_centerHorizontal= &quot;true&quot; // 相对于父容器水平居中</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<h2 id="相对于兄弟类控件的一个位置："><a href="#相对于兄弟类控件的一个位置：" class="headerlink" title="相对于兄弟类控件的一个位置："></a>相对于兄弟类控件的一个位置：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">layout_below = &quot;@+id/button&quot; // 该控件位于给定id控件的底部</div><div class="line">layout_toRightOf = ... // 右部</div><div class="line">layout_above // 上部</div><div class="line">layout_toLeftOf // 左边</div><div class="line"></div><div class="line">// 在一条线上</div><div class="line">layout_alignBottom // 该控件的底部边缘与给定的ID控件的底部边缘对齐</div><div class="line">Left // 左部对齐</div><div class="line">Right // 右部对齐</div><div class="line">Top // 顶部对齐</div></pre></td></tr></table></figure>
<h1 id="帧布局-FrameLayout"><a href="#帧布局-FrameLayout" class="headerlink" title="帧布局 FrameLayout"></a>帧布局 FrameLayout</h1><p>暂时没有参数说明</p>
<h1 id="绝对布局-AbsoluteLayout"><a href="#绝对布局-AbsoluteLayout" class="headerlink" title="绝对布局 AbsoluteLayout"></a>绝对布局 AbsoluteLayout</h1><p>很少使用，该类型的布局和iOS开发Frame布局很相识。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">layout_x // X的位置</div><div class="line">layout_y // Y的位置</div></pre></td></tr></table></figure>
<h1 id="表格布局-TableLayout"><a href="#表格布局-TableLayout" class="headerlink" title="表格布局 TableLayout"></a>表格布局 TableLayout</h1><p>该类型的布局和iOS开发中的StackView很相似。</p>
<h2 id="整体参数说明"><a href="#整体参数说明" class="headerlink" title="整体参数说明:"></a>整体参数说明:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">collapseColumns = &quot;1,2&quot; // 隐藏第1/2列</div><div class="line">shrinkColumns = &quot;1,2&quot; // 收缩第1/2列 ，全部收缩用&quot;*&quot;代替</div><div class="line">strtchColumns = &quot;1,2&quot; // 拉伸第1/2列 ，全部用&quot;*&quot;代替</div></pre></td></tr></table></figure>
<h2 id="内部控件所属属性："><a href="#内部控件所属属性：" class="headerlink" title="内部控件所属属性："></a>内部控件所属属性：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">layout_column = &quot;1&quot; // 该控件显示在第2列</div><div class="line">layout_span = &quot;2&quot; // 该控件占据2列</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 布局 </tag>
            
            <tag> android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[地图开发中的定位优化]]></title>
      <url>/2016/08/12/locationoptimize/</url>
      <content type="html"><![CDATA[<h1 id="定位漂移"><a href="#定位漂移" class="headerlink" title="定位漂移"></a>定位漂移</h1><p>百度地图在后台持续获取定位信息，并将定位信息绘制到百度地图上。由于在GPS信号很不好的情况下出现很严重的定位漂移，而百度并未提供去噪点功能，所以只有自己做优化。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>在成功获取第一个定位点的时候获取到当前的定位点保存。在此获取的点与之前一个点比较，求出两点之间的距离以及速度。当速度非常大（考虑到有可能乘坐动车，大于90m/s）忽略该点，认为该点是一个漂一点，但是效果并不理想。另一个，当前移动距离小于定位精确值的时候忽略该点。认为该点是一个漂移点，这样的设置大大降低了漂移点的数量。但是从实际效果上来看还是会出现漂移点。从漂移点上来看，大部分漂移点都集中在刚刚启动定位功能时。此时的定位精确度比较低，此时，决定在第二版做如下处理</p>
<ul>
<li>当定位精确度低于40m的时候，忽略所有点；</li>
<li>当精确度为10m～40m的时候，变化距离小于精度时，忽略该点；</li>
<li>精度高于10m的，且运动距离大于5m的采纳为有效点。</li>
</ul>
<p>当前定位精度值参考经度和纬度上最大值。</p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 定位 </tag>
            
            <tag> 精度 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS中的文件上传]]></title>
      <url>/2016/06/22/uploadfiles/</url>
      <content type="html"><![CDATA[<p>由于种种原因，之前向服务器上传头像的时候是通过将图片转换成<code>Base64</code>字符串进行传递的。这种方法有很大弊端：</p>
<ul>
<li>图片数据转换成<code>Base64</code>数据的时候需要占用大量的资源。转换的过程会出现内存和<code>CPU</code>达到一个较大峰值。在一些低端机上会出现失败的情况，此种情况在安卓端显得尤为严重。</li>
<li>另外，后台在存储的时候才用的是数据和资源分离的方案，有专门的图片服务器来负责处理和保存。在<code>App</code>服务器和图片服务器之间进行保存和传递的时候总是出现失败的情况。为了降低失败率移动端尽最大可能压缩图片，这样又导致另一个问题，图片严重失真，无法满足需求。</li>
</ul>
<p>基于以上两点，研究采用新的方式来上传文件。</p>
<p>经研究，文件的上传，可以通过两中方式，也就是<code>content-type</code>类型：</p>
<ul>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ul>
<h1 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a><code>multipart/form-data</code></h1><p><code>multipart/form-data</code>并非原始<code>HTTP</code>协议中支持的上传方法，属于<code>HTTP</code>客户端的一个扩展。常用在邮件上，可以一次向服务器上传多个附件。</p>
<h2 id="使用AFNetworking上传方法"><a href="#使用AFNetworking上传方法" class="headerlink" title="使用AFNetworking上传方法"></a>使用<code>AFNetworking</code>上传方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> [manager POST:url parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt;  _Nonnull formData) &#123;</div><div class="line">        </div><div class="line">        // serverName：服务器接收使用的文件名,具体和后台协商</div><div class="line">        // Client.jpg: 本地上传使用的文件名</div><div class="line">        // application/octet-stream : 服务器接收需要类型（此处表示不指定类型）</div><div class="line">        [formData appendPartWithFileData:UIImageJPEGRepresentation([UIImage imageNamed:@&quot;1&quot;], 1.0) name:@&quot;serverName&quot; fileName:@&quot;Client.jpg&quot; mimeType:@&quot;application/octet-stream&quot;];</div><div class="line">        </div><div class="line">&#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;</div><div class="line">    </div><div class="line">&#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</div><div class="line">        </div><div class="line">&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</div><div class="line">        </div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>要传递多个资源，只需要在<code>^(id&lt;AFMultipartFormData&gt;  _Nonnull formData){}</code>中添加多个资源即可。</p>
<p>如果服务器返回<code>code=200</code>错误,描述为：</p>
<blockquote>
<p>NSLocalizedDescription=Request failed: unacceptable content-type: text/plain}</p>
</blockquote>
<p>可以通过以下方法设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;,@&quot;text/html&quot;,@&quot;text/plain&quot;, nil];</div></pre></td></tr></table></figure>
<p>使用<code>Charles</code>查看请求内容，请求头信息如下：<br><img src="http://img.jessieedu.com/14980355211864.jpg" alt=""></p>
<p>若需要分析更详细内容可以使用<code>Wireshark</code>来分析。</p>
<p>开始向服务器上传文件的时候才用的是这种方式，发现到服务器无法进行解码。拿到服务器上的文件使用<code>vi</code>打开分析如下：<br><img src="http://img.jessieedu.com/14980361286591.jpg" alt=""><br>将这些信息删除以后，文件就可以正常打开了。但是，我在向服务器提交比较的数据时候，比如一个<code>pdf</code>和<code>mp3</code>文件一样带有这些信息，依然可以正常打开，此处留下一个疑问。<br><img src="http://img.jessieedu.com/14980364611641.jpg" alt=""></p>
<h1 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a><code>application/x-www-form-urlencoded</code></h1><p>使用类型为上传文件的默认方式：</p>
<h2 id="使用AFNetworing"><a href="#使用AFNetworing" class="headerlink" title="使用AFNetworing"></a>使用<code>AFNetworing</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">NSURL *url = [NSURL URLWithString:@&quot;http://192.168.2.51:5006/ashx/UploadHandler.ashx&quot;];</div><div class="line">    </div><div class="line">NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url];</div><div class="line">request.HTTPMethod = @&quot;POST&quot;;</div><div class="line">    </div><div class="line">NSData *data = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;111&quot; ofType:@&quot;mp3&quot;]];</div><div class="line">        </div><div class="line">[[manager uploadTaskWithRequest:request fromData:data progress:^(NSProgress * _Nonnull uploadProgress) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;,@(uploadProgress.fractionCompleted));</div><div class="line">&#125; completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) &#123;</div><div class="line">       </div><div class="line">    if (error) &#123;</div><div class="line">          NSLog(@&quot;error - %@&quot;,error);</div><div class="line">    &#125;else&#123;</div><div class="line">        NSLog(@&quot;responseObject - %@&quot;,responseObject);</div><div class="line">    &#125;</div><div class="line">&#125;] resume];</div></pre></td></tr></table></figure>
<h2 id="使用原生NSURLSession方式："><a href="#使用原生NSURLSession方式：" class="headerlink" title="使用原生NSURLSession方式："></a>使用原生<code>NSURLSession</code>方式：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];</div><div class="line">self.session = session;</div><div class="line">    </div><div class="line">[[session uploadTaskWithRequest:request fromData:data] resume];</div></pre></td></tr></table></figure>
<p>在代理中监听：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session didBecomeInvalidWithError:(nullable NSError *)error;</div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</div><div class="line">                                             completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler;</div><div class="line"></div><div class="line">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session NS_AVAILABLE_IOS(7_0);</div></pre></td></tr></table></figure>
<p>使用<code>Charles</code>查看网络请求头如下：<br><img src="http://img.jessieedu.com/14980390941948.jpg" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在后台给出具体的实施方案之后，结合上面两种方法来实现文件上传，即可轻松实现文件的上传。如果后台无法给出具体的是哪种方案，建议先尝试第二种方案。<br>另外，还是建议后台采用第一种方案来实现。可以一次性传递多个资源，而后者则无法达到。第二种方案要实现多图上传的话只能通过多线程循环调用来实现。在这一点上，还是第一种比较优雅一些。</p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UIWebView／WKWebView 加载多种数据]]></title>
      <url>/2016/05/09/webview/</url>
      <content type="html"><![CDATA[<p>在最近的项目中，有一个用户注册协议客户给的是<code>.doc</code>文件。</p>
<p>在<code>iOS</code>中，<code>UIWebView</code>加载数据有三种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)loadRequest:(NSURLRequest *)request;</div><div class="line"></div><div class="line">- (void)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;</div><div class="line"></div><div class="line">- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;</div></pre></td></tr></table></figure>
<p>第一种，一般用于加载一个<code>URL</code>地址，后面传入一个<code>NSURLRequest</code>。第二种，一般用于加载一个<code>HTML</code>字符串，<code>baseURL</code>为其他文件资源路径。这里主要介绍第三种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;</div></pre></td></tr></table></figure>
<p><code>apple</code>官方文档说明很简单：<strong>Sets the main page contents, MIME type, content encoding, and base URL.</strong>，参数说明如表：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>The content for the main page.</td>
</tr>
<tr>
<td>MIMEType</td>
<td>The MIME type of the content.</td>
</tr>
<tr>
<td>encodingName</td>
<td>The IANA encoding name as in utf-8 or utf-16.</td>
</tr>
<tr>
<td>baseURL</td>
<td>The base URL for the content.</td>
</tr>
</tbody>
</table>
<p>其中参数<code>MIMEType</code>在<a href="https://www.sitepoint.com/web-foundations/mime-types-summary-list/" target="_blank" rel="external">sitepoint</a>查询常用类型如表：</p>
<table>
<thead>
<tr>
<th>文件格式</th>
<th>MIMEType 值</th>
</tr>
</thead>
<tbody>
<tr>
<td>.doc</td>
<td>application/msword</td>
</tr>
<tr>
<td>.docx</td>
<td>application/vnd.openxmlformats-officedocument.wordprocessingml.document</td>
</tr>
<tr>
<td>.dotx</td>
<td>application/vnd.openxmlformats-officedocument.wordprocessingml.template</td>
</tr>
<tr>
<td>.gif</td>
<td>image/gif</td>
</tr>
<tr>
<td>.html</td>
<td>text/html</td>
</tr>
<tr>
<td>.jpg</td>
<td>image/jpeg</td>
</tr>
<tr>
<td>.pdf</td>
<td>application/pdf</td>
</tr>
<tr>
<td>.ppt</td>
<td>application/vnd.ms-powerpointtd&gt;</td>
</tr>
<tr>
<td>.pptx</td>
<td>application/vnd.openxmlformats-officedocument.presentationml.presentation</td>
</tr>
<tr>
<td>.xls</td>
<td>application/vnd.ms-excel</td>
</tr>
<tr>
<td>.xlsx</td>
<td>application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</td>
</tr>
<tr>
<td>.xml</td>
<td>application/xml</td>
</tr>
</tbody>
</table>
<p>接下来加载文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 获取文件</div><div class="line">NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;RegisterProtocol.docx&quot; ofType:nil];</div><div class="line">NSData *data = [NSData dataWithContentsOfFile:path];</div><div class="line"></div><div class="line">//加载本地word文档</div><div class="line">[self.webView loadData:data MIMEType:@&quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document&quot; textEncodingName:@&quot;utf-8&quot; baseURL:[NSURL URLWithString:path]];</div></pre></td></tr></table></figure>
<p>在<code>WKWebView</code>中，加载数据有四种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (nullable WKNavigation *)loadRequest:(NSURLRequest *)request;</div><div class="line"></div><div class="line">- (nullable WKNavigation *)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;</div><div class="line"></div><div class="line">- (nullable WKNavigation *)loadFileURL:(NSURL *)URL allowingReadAccessToURL:(NSURL *)readAccessURL API_AVAILABLE(macosx(10.11), ios(9.0));</div><div class="line"></div><div class="line">- (nullable WKNavigation *)loadData:(NSData *)data MIMEType:(NSString *)MIMEType characterEncodingName:(NSString *)characterEncodingName baseURL:(NSURL *)baseURL API_AVAILABLE(macosx(10.11), ios(9.0));</div></pre></td></tr></table></figure>
<p>其中前两者和<code>UIWebView</code>相同，而后两者紧紧在<code>iOS9</code>之后生效。</p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> UIWebView </tag>
            
            <tag> WKWebView </tag>
            
            <tag> 数据加载 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[修饰词笔记]]></title>
      <url>/2016/03/26/qualifier/</url>
      <content type="html"><![CDATA[<h1 id="weak-amp-strong"><a href="#weak-amp-strong" class="headerlink" title="weak &amp; strong"></a><code>weak</code> &amp; <code>strong</code></h1><p><code>weak</code>和<code>strong</code>修饰的均为对象类型。当一个对象不在有<code>strong</code>类型的指针指向它的时候，该对象会被释放。当无<code>strong</code>指针指向的时候，所有<code>weak</code>类型的指针都将被清除。</p>
<h1 id="assign-amp-copy-amp-retain"><a href="#assign-amp-copy-amp-retain" class="headerlink" title="assign &amp; copy &amp; retain"></a><code>assign</code> &amp; <code>copy</code> &amp; <code>retain</code></h1><ul>
<li><code>assign</code>:简单赋值，不更改引用计数，用于基础数据。</li>
<li><code>copy</code>： 建立一个索引计数为1的对象，然后释放旧对象。一般用于<code>NSString</code>和<code>Block</code>。</li>
<li><code>retain</code>：释放旧的对象，将旧对象的值赋予输入对象，对输入对象的引用计数加1，用于<code>NSObject</code>以及子类。</li>
</ul>
<p><code>copy</code>应用修饰于可变数据类型时，会将可变类型的数据拷为不可变类型，例如：</p>
<ul>
<li><code>NSMutableString</code>  -&gt; <code>NSString</code></li>
<li><code>NSMutableDictory</code> -&gt; <code>NSDictory</code></li>
<li><code>NSMutableArray</code>   -&gt; <code>NSArray</code></li>
</ul>
<p><code>copy</code>在内部创建一个对象，属于内容拷贝，<code>reatain</code>只是拷贝指针。在<code>MRC</code>时期用于修饰对象类型，等同于<code>ARC</code>下的<code>strong</code>。</p>
<h1 id="block-amp-weak"><a href="#block-amp-weak" class="headerlink" title="__block &amp; __weak"></a><code>__block</code> &amp; <code>__weak</code></h1><blockquote>
<p><code>__block</code>在<code>ARC</code>和<code>MRC</code>下均可使用，可以修饰对象和基本数据类型。</p>
<p><code>__weak</code>只能在<code>ARC</code>模式下使用，也只能修饰对象。</p>
<p><code>__block</code>对象可以在<code>blcok</code>中重新赋值，<code>__weak</code> 不可以。</p>
</blockquote>
<h1 id="深复制和浅复制"><a href="#深复制和浅复制" class="headerlink" title="深复制和浅复制"></a>深复制和浅复制</h1><ul>
<li><code>copy</code> / <code>mutablecopy</code> 对 <code>NSString</code> 的影响：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;test&quot;;</div><div class="line"></div><div class="line">NSString *copyString = [string copy];</div><div class="line"></div><div class="line">NSMutableString *mutableCopyString = [string mutableCopy];</div><div class="line"></div><div class="line">NSLog(@&quot;\nstring = %p\ncopyString = %p\nmutableCopyString = %p&quot;, string, copyString, mutableCopyString);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string = 0x106eac600</div><div class="line">copyString = 0x106eac600</div><div class="line">mutableCopyString = 0x61800006f840</div></pre></td></tr></table></figure>
<ul>
<li><code>copy</code> / <code>mutablecopy</code> 对 <code>NSMutableString</code> 的影响：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSMutableString *string = [NSMutableString stringWithString:@&quot;test&quot;];</div><div class="line"></div><div class="line">NSString *copyString = [string copy];</div><div class="line"></div><div class="line">NSMutableString *mutableCopyString = [string mutableCopy];</div><div class="line"></div><div class="line">NSLog(@&quot;\nstring = %p\ncopyString = %p\nmutableCopyString = %p&quot;, string, copyString, mutableCopyString);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string = 0x610000072b00</div><div class="line">copyString = 0xa000000747365744</div><div class="line">mutableCopyString = 0x610000072b40</div></pre></td></tr></table></figure>
<p>适用于<code>NSArray</code>、<code>NSMutableArray</code> 、<code>NSDictionary</code>、<code>NSMutableDictionary</code></p>
<p>得出如下结论：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>copy（是否产生新对象）</th>
<th>mutableCopy（是否产生新对象）</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSString</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>NSMutableString</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>NSArray</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>NSMutableArray</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>NSDictionary</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>NSMutableDictionary</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<ul>
<li>copy <code>NSObject</code></li>
</ul>
<p>对于继承<code>NSObject</code>类型的自定义对象，要实现<code>copy</code>需要遵守<code>NSCopy</code>协议并实现以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)copyWithZone:(NSZone *)zone;</div></pre></td></tr></table></figure>
<p>该方法内部根据实际情况创建一个新的对象，并将旧值赋值给新的对象。</p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 修饰词 </tag>
            
            <tag> weak </tag>
            
            <tag> strong </tag>
            
            <tag> assign </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POP动画库简单使用]]></title>
      <url>/2016/03/26/pop/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/facebook/pop" target="_blank" rel="external"><code>POP</code></a>是<code>Facebook</code>开源的一个动画库，该动画库基于<code>CADisplayLink</code>(Mac平台上使用的<code>CVDisplayLink</code>)实现的独立于<code>Core Animation</code>之外的动画库。以每秒60帧的速度渲染动画，所以看起来会非常流畅。</p>
<p>创建一个<code>POP</code>动画需要六步，下面我们来逐一介绍：</p>
<h2 id="选择一个动画方式："><a href="#选择一个动画方式：" class="headerlink" title="选择一个动画方式："></a>选择一个动画方式：</h2><p><code>POP</code>提供4种动画效果，<code>POPBasicAnimation</code>、<code>POPSpringAnimation</code>、<code>POPDecayAnimation</code>、<code>POPCustomAnimation</code>。这些动画效果可以基于<code>CALayer</code>、<code>CAShapeLayer</code>、<code>NSLayoutConstraint</code>、<code>UIView</code>、<code>UIScrollView</code>、<code>UITableView</code>、<code>UINavigationBar</code>、<code>UITabBar</code>等类。</p>
<blockquote>
<p><code>POPBasicAnimation</code>是一种基础动画，提供最基本的动画效果。接口方面和<code>CABasicAniamtion</code>很相似，使用可以提供初始值<code>fromValue</code>，这个 终点值<code>toValue</code>，动画时长<code>duration</code>以及决定动画节奏的<code>timingFunction</code>。其创建方式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">POPBasicAnimation *basicAnimation = [POPBasicAnimation animation]; // 创建动画</div></pre></td></tr></table></figure>
<blockquote>
<p><code>POPSpringAnimation</code> 弹簧动画是<code>Bezier</code>曲线无法表述的，所以无法使用<code>PopBasicAniamtion</code>来实现。<code>PopSpringAnimation</code>便是专门用来实现弹簧动画的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">POPSpringAnimation *springAnimation = [POPSpringAnimation animation];</div><div class="line">springAnimation.velocity=@(1000); // change of value units per second每秒都改变属性</div><div class="line">springAnimation.springBounciness=14; // value between 0-20 default at 4值的范围是0~20 默认为4</div><div class="line">springAnimation.springSpeed=3; // value between 0-20 default at 4</div></pre></td></tr></table></figure>
<blockquote>
<p><code>POPDecayAnimation</code>基于<code>Bezier</code>曲线的<code>timingFuntion</code>,同样无法表述<code>Decay Aniamtion</code>，所以<code>Pop</code>就单独实现了一个 <code>PopDecayAnimation</code>，用于衰减动画。衰减动画一个很常见的地方就是 <code>UIScrollView</code> 滑动松开后的减速当滑动手势结束时，根据结束的加速度，给衰减动画一个初始的<code>velocity</code>，用来决定衰减的时长。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPDecayAnimation *decayAnimation=[POPDecayAnimation animation];</div><div class="line">decayAnimation.velocity=@(233); //change of value units per second</div><div class="line">decayAnimation.deceleration=.833; //range of 0 to 1</div></pre></td></tr></table></figure>
<blockquote>
<p><code>POPCustomAnimation</code>继承自<code>PopAnimation</code>用于创建自定义动画用的，通过<code>POPCustomAnimationBlock</code>类型的<code>block</code>进行初始化.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef BOOL (^POPCustomAnimationBlock)(id target, POPCustomAnimation *animation);</div></pre></td></tr></table></figure>
<p>此<code>block</code>会在界面的每一帧更新的时候被调用，创建者需要在<code>block</code>中根据当前<code>currentTime</code>和<code>elapsedTime</code>来决定如何更新<code>target</code>的相关属性，以实现特定的动画。当你需要结束动画的时候就在<code>block</code>中返回<code>NO</code>，否则返回<code>YES</code>。</p>
<h2 id="选择你的动画属性"><a href="#选择你的动画属性" class="headerlink" title="选择你的动画属性"></a>选择你的动画属性</h2><p>在创建动画的时候，我们可以直接选择动画的属性，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">POPBasicAnimation *anim = [POPBasicAnimation    animationWithPropertyNamed:kPOPLayerScaleXY]; // 这里修改的是视图的XY上的缩放属性</div></pre></td></tr></table></figure>
<blockquote>
<p><code>View Properties</code> 视图属性：</p>
</blockquote>
<ul>
<li>Alpha - kPOPViewAlpha</li>
<li>Color - kPOPViewBackgroundColor</li>
<li>Size - kPOPViewBounds</li>
<li>Center - kPOPViewCenter</li>
<li>Location &amp; Size - kPOPViewFrame</li>
<li>Size - kPOPViewScaleXY</li>
<li>Size(Scale) - kPOPViewSize</li>
</ul>
<blockquote>
<p><code>Layer Properties</code> 层属性</p>
</blockquote>
<ul>
<li>Color - kPOPLayerBackgroundColor</li>
<li>Size - kPOPLayerBounds</li>
<li>Size - kPOPLayerScaleXY</li>
<li>Size - kPOPLayerSize</li>
<li>Opacity - kPOPLayerOpacity</li>
<li>Position - kPOPLayerPosition</li>
<li>X Position - kPOPLayerPositionX</li>
<li>Y Position - kPOPLayerPositionY</li>
<li>Rotation - kPOPLayerRotation</li>
<li>Color - kPOPLayerBackgroundColor</li>
</ul>
<h2 id="设置时间曲线"><a href="#设置时间曲线" class="headerlink" title="设置时间曲线"></a>设置时间曲线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">    basicAnimation.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</div><div class="line">// kCAMediaTimingFunctionLinear kCAMediaTimingFunctionEaseIn    kCAMediaTimingFunctionEaseOut kCAMediaTimingFunctionEaseInEaseOut // 时间类型显示</div></pre></td></tr></table></figure>
<ul>
<li>kCAMediaTimingFunctionLinear // 属性随时间均匀变化</li>
<li>kCAMediaTimingFunctionEaseIn // 先慢后快</li>
<li>kCAMediaTimingFunctionEaseOut // 先快后慢</li>
<li>kCAMediaTimingFunctionEaseInEaseOut // S形变化</li>
</ul>
<p>该设置在<code>POPDecayAnimation</code>、<code>POPSpringAnimation</code>中是不起效果的。</p>
<h2 id="设置属性变化值"><a href="#设置属性变化值" class="headerlink" title="设置属性变化值"></a>设置属性变化值</h2><h3 id="View-Properties"><a href="#View-Properties" class="headerlink" title="View Properties"></a>View Properties</h3><h4 id="Alpha-kPOPViewAlpha"><a href="#Alpha-kPOPViewAlpha" class="headerlink" title="Alpha - kPOPViewAlpha"></a>Alpha - kPOPViewAlpha</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPBasicAnimation *basicAnimation = [POPBasicAnimation animation];</div><div class="line">basicAnimation.property = [POPAnimatableProperty    propertyWithName:kPOPViewAlpha];</div><div class="line">basicAnimation.toValue= @(0); // scale from 0 to 1 缩放的范围0~1</div></pre></td></tr></table></figure>
<h4 id="Color-kPOPViewBackgroundColor"><a href="#Color-kPOPViewBackgroundColor" class="headerlink" title="Color - kPOPViewBackgroundColor"></a>Color - kPOPViewBackgroundColor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPSpringAnimation *basicAnimation = [POPSpringAnimation animation];</div><div class="line">basicAnimation.property = [POPAnimatableProperty propertyWithName:  kPOPLayerBackgroundColor];</div><div class="line">basicAnimation.toValue= [UIColor redColor];</div></pre></td></tr></table></figure>
<h4 id="Size-kPOPViewBounds"><a href="#Size-kPOPViewBounds" class="headerlink" title="Size - kPOPViewBounds"></a>Size - kPOPViewBounds</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPBasicAnimation *basicAnimation = [POPBasicAnimation animation];</div><div class="line">basicAnimation.property = [POPAnimatableProperty    propertyWithName:kPOPViewBounds];</div><div class="line">basicAnimation.toValue=[NSValue valueWithCGRect:CGRectMake(0, 0, 90, 190)]; //first 2 values dont matter</div></pre></td></tr></table></figure>
<h4 id="Center-kPOPViewCenter"><a href="#Center-kPOPViewCenter" class="headerlink" title="Center - kPOPViewCenter"></a>Center - kPOPViewCenter</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPBasicAnimation *basicAnimation = [POPBasicAnimation animation];</div><div class="line">basicAnimation.property = [POPAnimatableProperty    propertyWithName:kPOPViewCenter];</div><div class="line">basicAnimation.toValue=[NSValue valueWithCGPoint:CGPointMake(200, 200)];</div></pre></td></tr></table></figure>
<h4 id="Location-amp-Size-kPOPViewFrame"><a href="#Location-amp-Size-kPOPViewFrame" class="headerlink" title="Location &amp; Size - kPOPViewFrame"></a>Location &amp; Size - kPOPViewFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPBasicAnimation *basicAnimation = [POPBasicAnimation animation];</div><div class="line">basicAnimation.property = [POPAnimatableProperty    propertyWithName:kPOPViewFrame];</div><div class="line">basicAnimation.toValue=[NSValue valueWithCGRect:CGRectMake(140, 140, 140, 140)];</div></pre></td></tr></table></figure>
<h4 id="Size-kPOPViewScaleXY"><a href="#Size-kPOPViewScaleXY" class="headerlink" title="Size - kPOPViewScaleXY"></a>Size - kPOPViewScaleXY</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPBasicAnimation *basicAnimation = [POPBasicAnimation animation];</div><div class="line">basicAnimation.property = [POPAnimatableProperty    propertyWithName:kPOPViewScaleXY];</div><div class="line">basicAnimation.toValue=[NSValue valueWithCGSize:CGSizeMake(3, 2)];</div></pre></td></tr></table></figure>
<h4 id="Size-Scale-kPOPViewSize"><a href="#Size-Scale-kPOPViewSize" class="headerlink" title="Size(Scale) - kPOPViewSize"></a>Size(Scale) - kPOPViewSize</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPBasicAnimation *basicAnimation = [POPBasicAnimation animation];</div><div class="line">basicAnimation.property = [POPAnimatableProperty propertyWithName:kPOPViewSize];</div><div class="line">basicAnimation.toValue=[NSValue valueWithCGSize:CGSizeMake(30, 200)];</div></pre></td></tr></table></figure>
<h3 id="Layer-Properties"><a href="#Layer-Properties" class="headerlink" title="Layer Properties"></a>Layer Properties</h3><h4 id="Color-kPOPLayerBackgroundColor"><a href="#Color-kPOPLayerBackgroundColor" class="headerlink" title="Color - kPOPLayerBackgroundColor"></a>Color - kPOPLayerBackgroundColor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPSpringAnimation *basicAnimation = [POPSpringAnimation animation];</div><div class="line">basicAnimation.property = [POPAnimatableProperty propertyWithName: kPOPLayerBackgroundColor];</div><div class="line">basicAnimation.toValue= [UIColor redColor];</div></pre></td></tr></table></figure>
<h4 id="Size-kPOPLayerBounds"><a href="#Size-kPOPLayerBounds" class="headerlink" title="Size - kPOPLayerBounds"></a>Size - kPOPLayerBounds</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPSpringAnimation *basicAnimation = [POPSpringAnimation animation];</div><div class="line">basicAnimation.property = [POPAnimatableProperty propertyWithName: kPOPLayerBounds];</div><div class="line">basicAnimation.toValue= [NSValue valueWithCGRect:CGRectMake(0, 0, 90, 90)]; //first 2 values dont matter</div></pre></td></tr></table></figure>
<h4 id="Size-kPOPLayerScaleXY"><a href="#Size-kPOPLayerScaleXY" class="headerlink" title="Size - kPOPLayerScaleXY"></a>Size - kPOPLayerScaleXY</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPBasicAnimation *basicAnimation = [POPBasicAnimation animation];</div><div class="line">basicAnimation.property = [POPAnimatableProperty propertyWithName: kPOPLayerScaleXY];</div><div class="line">basicAnimation.toValue= [NSValue valueWithCGSize:CGSizeMake(2, 1)];//increases width and height scales</div></pre></td></tr></table></figure>
<h4 id="Size-kPOPLayerSize"><a href="#Size-kPOPLayerSize" class="headerlink" title="Size - kPOPLayerSize"></a>Size - kPOPLayerSize</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPBasicAnimation *basicAnimation = [POPBasicAnimation animation];</div><div class="line">basicAnimation.property = [POPAnimatableProperty    propertyWithName:kPOPLayerSize];</div><div class="line">basicAnimation.toValue= [NSValue valueWithCGSize:CGSizeMake(200, 200)];</div></pre></td></tr></table></figure>
<h4 id="Opacity-kPOPLayerOpacity"><a href="#Opacity-kPOPLayerOpacity" class="headerlink" title="Opacity - kPOPLayerOpacity"></a>Opacity - kPOPLayerOpacity</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPSpringAnimation *basicAnimation = [POPSpringAnimation animation];</div><div class="line">basicAnimation.property = [POPAnimatableProperty propertyWithName: kPOPLayerOpacity];</div><div class="line">basicAnimation.toValue = @(0);</div></pre></td></tr></table></figure>
<h4 id="Position-kPOPLayerPosition"><a href="#Position-kPOPLayerPosition" class="headerlink" title="Position - kPOPLayerPosition"></a>Position - kPOPLayerPosition</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPSpringAnimation *basicAnimation = [POPSpringAnimation animation];</div><div class="line">basicAnimation.property = [POPAnimatableProperty propertyWithName: kPOPLayerPosition];</div><div class="line">basicAnimation.toValue= [NSValue valueWithCGRect:CGRectMake(130, 130, 0, 0)];//last 2 values dont matter</div></pre></td></tr></table></figure>
<h4 id="X-Position-kPOPLayerPositionX"><a href="#X-Position-kPOPLayerPositionX" class="headerlink" title="X Position - kPOPLayerPositionX"></a>X Position - kPOPLayerPositionX</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPSpringAnimation *basicAnimation = [POPSpringAnimation animation];</div><div class="line">basicAnimation.property = [POPAnimatableProperty propertyWithName: kPOPLayerPositionX];</div><div class="line">basicAnimation.toValue= @(240);</div></pre></td></tr></table></figure>
<h4 id="Y-Position-kPOPLayerPositionY"><a href="#Y-Position-kPOPLayerPositionY" class="headerlink" title="Y Position - kPOPLayerPositionY"></a>Y Position - kPOPLayerPositionY</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPSpringAnimation *anim = [POPSpringAnimation animation];</div><div class="line">anim.property=[POPAnimatableProperty propertyWithName:kPOPLayerPositionY];</div><div class="line">anim.toValue = @(320);</div></pre></td></tr></table></figure>
<h4 id="Rotation-kPOPLayerRotation"><a href="#Rotation-kPOPLayerRotation" class="headerlink" title="Rotation - kPOPLayerRotation"></a>Rotation - kPOPLayerRotation</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POPSpringAnimation *basicAnimation = [POPSpringAnimation animation];</div><div class="line">basicAnimation.property = [POPAnimatableProperty propertyWithName: kPOPLayerRotation];</div><div class="line">basicAnimation.toValue= @(M_PI/4); //2 M_PI is an entire rotation</div></pre></td></tr></table></figure>
<h2 id="设置代理和名字"><a href="#设置代理和名字" class="headerlink" title="设置代理和名字"></a>设置代理和名字</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">basicAnimation.name=@&quot;animationName&quot;; // 这个名字根据自己的需要来添加</div><div class="line">basicAnimation.delegate=self;</div></pre></td></tr></table></figure>
<p>代理实现一下来监听动画执行状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Declare Delegate Protocol &lt;POPAnimatorDelegate&gt;声明代理协议</div><div class="line">Delegate Methods 代理方法 &lt;POPAnimatorDelegate&gt;</div><div class="line"></div><div class="line">- (void)animatorWillAnimate:(POPAnimator *)animator; // 将要执行动画的方法</div><div class="line">- (void)animatorDidAnimate:(POPAnimator *)animator;  // 执行完动画的方法</div></pre></td></tr></table></figure>
<p>在这里我们就可以根据动画的执行状态做一些我们自己的业务了，当然我们同样可以通过<code>block</code>的方式来实现。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">anim.completionBlock = ^(POPAnimation *anim, BOOL finished) &#123;</div><div class="line">    if (finished) &#123;</div><div class="line">        // do something here</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>##6.选择动画的添加位置</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.tableView pop_addAnimation:basicAnimation     forKey:@&quot;WhatEverNameYouWant&quot;];</div></pre></td></tr></table></figure>
<p>其实这一步的Key也就是我们上一步设置的Name属性，设置该名字以后，在代理方法中我们就可以根据Name值来区别动画，然后根据不同的动画执行我们需要的代码。</p>
<hr>
<p>总结：<code>Pop Animation</code>应用于<code>CALayer</code>时，在动画运行的任何时刻，<code>layer</code>和其<code>presentationLayer</code>的相关属性值始终保持一致，而<code>Core Animation</code>做不到。<code>Pop Animation</code>可以应用任何<code>NSObject</code>的对象，而<code>Core Aniamtion</code>必须是<code>CALayer</code>。</p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> POP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CALayer简单使用]]></title>
      <url>/2016/02/26/calayer/</url>
      <content type="html"><![CDATA[<h1 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h1><p>在我们正常开发中，这个是使用最多的。通过<code>CALayer</code>可以设置边框以及圆角、阴影等属性，<code>Core Animation</code>动画就是添加在<code>CALayer</code>之上的效果.</p>
<h1 id="CATextLayer"><a href="#CATextLayer" class="headerlink" title="CATextLayer"></a>CATextLayer</h1><p>通过<code>CATextLayer</code>可以封装自己的<code>Label</code>控件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CATextLayer *textLayer = [CATextLayer layer];</div><div class="line">textLayer.string = @&quot;CATextLayer&quot;;</div><div class="line">textLayer.font = CFBridgingRetain([UIFont systemFontOfSize:18]); // 设置字体 Helvetic</div><div class="line">textLayer.allowsFontSubpixelQuantization = YES;//允许字体 像素数字化</div><div class="line">textLayer.fontSize = 20; // 控制文字大小</div><div class="line">textLayer.foregroundColor = [UIColor redColor].CGColor; // 文字颜色</div><div class="line">textLayer.wrapped = YES;</div><div class="line">textLayer.bounds = (CGRect)&#123;&#123;0,0&#125;,&#123;100,100&#125;&#125;;</div><div class="line">textLayer.position = CGPointMake(100, 100);</div><div class="line">[self.view.layer addSublayer:textLayer];</div></pre></td></tr></table></figure>
<h1 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h1><p><code>CAShapeLayer</code>和贝塞尔曲线接合可以画出做出很炫的动画以及各种不规则的效果。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 创建bezierPath曲线</div><div class="line">UIBezierPath *bezierPath = [UIBezierPath bezierPath];</div><div class="line">[bezierPath moveToPoint:CGPointMake(0, 0)];</div><div class="line">[bezierPath addCurveToPoint:CGPointMake(250, 400) controlPoint1:CGPointMake(200, 100) controlPoint2:CGPointMake(50, 350)];</div><div class="line">// 设置shapeLayer的path为贝塞尔曲线的路径</div><div class="line">CAShapeLayer *shapeLayer = [CAShapeLayer layer];</div><div class="line">shapeLayer.path = bezierPath.CGPath;</div><div class="line">shapeLayer.strokeColor = [UIColor redColor].CGColor; // 线的颜色</div><div class="line">shapeLayer.fillColor = [UIColor whiteColor].CGColor; // 起点终点连线和Path线包含进去的区域颜色</div><div class="line">shapeLayer.lineWidth = 4;</div><div class="line">//根据bezierPath 获取 CAShapeLayer</div><div class="line">CGPathRef pathRef = CGPathCreateCopyByStrokingPath(shapeLayer.path, NULL, bezierPath.lineWidth, kCGLineCapRound, kCGLineJoinRound, shapeLayer.miterLimit);</div><div class="line">//获取 路径的范围CGPathGetBoundingBox()</div><div class="line">shapeLayer.bounds = CGPathGetBoundingBox(pathRef);</div><div class="line">CGPathRelease(pathRef);</div><div class="line">shapeLayer.position = self.view.center;</div><div class="line">shapeLayer.backgroundColor = [UIColor orangeColor].CGColor; ／／ 整个layer的bgColor</div><div class="line">[self.view.layer addSublayer:shapeLayer];</div></pre></td></tr></table></figure>
<h1 id="CATiledLayer"><a href="#CATiledLayer" class="headerlink" title="CATiledLayer"></a>CATiledLayer</h1><p>有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。<code>iOS</code>应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的-imageNamed:方法或者-imageWithContentsOfFile:方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。要解决这个问题，我们就可以借助<code>CATiledLayer</code>，首先，我们将大图切成多个小图，并保存到本地。在<code>- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx</code>中取出相对应的图片并绘制出来。具体可以参考<a href="https://zsisme.gitbooks.io/ios-/content/chapter6/catiledLayer.html" target="_blank" rel="external">CATiledLayer</a>。</p>
<h1 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h1><p><code>CAGradientLayer</code>是用来生成两种或更多颜色平滑渐变的。相比于<code>Core Graphics</code>，它最大的好处是使用了硬件加速。<code>startPoint</code>和<code>endPoint</code>决定了渐变的方向。这两个参数是以单位坐标系进行的定义的，即范围为{0,0}~{1,1}。使用<code>mask</code>来确定改变哪个图层的变化值。<br><code>color</code>属性可以包含很多颜色，默认情况下多个颜色值是均匀渲染在<code>layer</code>中，但是我们也可以通过<code>locations</code>参数调整。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">CAGradientLayer *gradientLayer = [CAGradientLayer layer];</div><div class="line">gradientLayer.frame = self.containerView.bounds;</div><div class="line">[self.containerView.layer addSublayer:gradientLayer];</div><div class="line">//set gradient colors</div><div class="line">gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id) [UIColor yellowColor].CGColor, (__bridge id)[UIColor greenColor].CGColor];</div><div class="line">//set locations</div><div class="line">gradientLayer.locations = @[@0.0, @0.25, @0.5];</div><div class="line">//set gradient start and end points</div><div class="line">gradientLayer.startPoint = CGPointMake(0, 0);</div><div class="line">gradientLayer.endPoint = CGPointMake(1, 1);</div><div class="line">当然，我们也可以将颜色变化做成动画的效果：</div><div class="line">CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@&quot;colors&quot;];</div><div class="line">animation.duration = 2;</div><div class="line">animation.repeatCount = MAXFLOAT;</div><div class="line">NSMutableArray *toValue = [NSMutableArray array];</div><div class="line">for (NSInteger i = 0; i &lt; count ; i ++) &#123;</div><div class="line">UIColor *color = [UIColor colorWithRed:arc4random_uniform(255)/255.0 green:arc4random_uniform(255)/255.0 blue:arc4random_uniform(255)/255.0 alpha:1];</div><div class="line">[toValue addObject:(__bridge id)color.CGColor];</div><div class="line">&#125;</div><div class="line">animation.autoreverses = YES;</div><div class="line">animation.toValue = toValue;</div><div class="line">[gradientLayer addAnimation:animation forKey:@&quot;gradientLayer&quot;];</div></pre></td></tr></table></figure>
<h1 id="CAEmitterLayer"><a href="#CAEmitterLayer" class="headerlink" title="CAEmitterLayer"></a>CAEmitterLayer</h1><p><code>CAEmitterLayer</code>是一种基于<code>Core Animation</code>的粒子发生器。这里有一个使用<code>CAEmitterLayer</code>实现的特效，包括雪花，烟花，火焰，爱心等效果:<a href="https://zsisme.gitbooks.io/ios-/content/chapter6/6.14.png" target="_blank" rel="external">CAEmitterLayer</a></p>
<h1 id="CATransformLayer"><a href="#CATransformLayer" class="headerlink" title="CATransformLayer"></a>CATransformLayer</h1><p><code>CATransformLayer</code>是一种提供<code>3D</code>动画效果的<code>layer</code>容器。向容器中填加不同的涂层，对不同的涂层进行组合来展示一个三维的效果。通过<code>m34</code>参数来设置视点位置，其中<code>m34</code>的值越小效果也就越逼真。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct CATransform3D</div><div class="line">&#123;</div><div class="line">  CGFloat m11, m12, m13, m14;</div><div class="line">  CGFloat m21, m22, m23, m24;</div><div class="line">  CGFloat m31, m32, m33, m34;</div><div class="line">  CGFloat m41, m42, m43, m44;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>从m11到m44定义的含义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">m11：x轴方向进行缩放</div><div class="line">m12：和m21一起决定z轴的旋转</div><div class="line">m13:和m31一起决定y轴的旋转</div><div class="line">m14:</div><div class="line">m21:和m12一起决定z轴的旋转</div><div class="line">m22:y轴方向进行缩放</div><div class="line">m23:和m32一起决定x轴的旋转</div><div class="line">m24:</div><div class="line">m31:和m13一起决定y轴的旋转</div><div class="line">m32:和m23一起决定x轴的旋转</div><div class="line">m33:z轴方向进行缩放</div><div class="line">m34:透视效果m34= -1/D，D越小，透视效果越明显，必须在有旋转效果的前提下，才会看到透视效果</div><div class="line">m41:x轴方向进行平移</div><div class="line">m42:y轴方向进行平移</div><div class="line">m43:z轴方向进行平移</div><div class="line">m44:初始为1</div></pre></td></tr></table></figure>
<hr>
<p>参考资料：<a href="https://www.gitbook.com/book/zsisme/ios-/details" target="_blank" rel="external">iOS核心动画高级技巧</a></p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CALayer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTPS认证过程]]></title>
      <url>/2015/11/27/httpsauth/</url>
      <content type="html"><![CDATA[<ol>
<li><p>浏览器发送一个连接请求给安全服务器。</p>
</li>
<li><p>服务器将自己的证书，以及同证书相关的信息发送给客户浏览器。</p>
</li>
<li><p>客户浏览器检查服务器送过来的证书是否是由自己信赖的 CA 中心所签发的。如果是，就继续执行协议；如果不是，客户浏览器就给客户一个警告消息：警告客户这个证书不是可以信赖的，询问客户是否需要继续。</p>
</li>
<li><p>接着客户浏览器比较证书里的消息，例如域名和公钥，与服务器刚刚发送的相关消息是否一致，如果是一致的，客户浏览器认可这个服务器的合法身份。</p>
</li>
<li><p>服务器要求客户发送客户自己的证书。收到后，服务器验证客户的证书，如果没有通过验证，拒绝连接；如果通过验证，服务器获得用户的公钥。</p>
</li>
<li><p>客户浏览器告诉服务器自己所能够支持的通讯对称密码方案。</p>
</li>
<li><p>服务器从客户发送过来的密码方案中，选择一种加密程度最高的密码方案，用客户的公钥加过密后通知浏览器。</p>
</li>
<li><p>浏览器针对这个密码方案，选择一个通话密钥，接着用服务器的公钥加过密后发送给服务器。</p>
</li>
<li><p>服务器接收到浏览器送过来的消息，用自己的私钥解密，获得通话密钥。</p>
</li>
<li><p>服务器、浏览器接下来的通讯都是用对称密码方案，对称密钥是加过密的</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> iOS学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> https </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS中GCD的使用]]></title>
      <url>/2015/11/19/iOSGCD/</url>
      <content type="html"><![CDATA[<p>从<code>iOS4</code>时期，苹果引入了<code>GCD</code>技术，<code>GCD</code>(<code>Grand Central Dispatch</code>)是异步执行任务的技术之一。一般将应用程序中描述的线程管理用的代码在系统级中实现。开发者只需定义想执行的任务并追加到适当的<code>Dispatch Queue</code>中，<code>GCD</code>就能生成必要的线程并计划执行任务。而线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样大大提高了线程的效率。</p>
<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><p>在<code>iOS</code>开发中，前期<code>CPU</code>均为单核设计。 源码编译后的机器语言在<code>CPU</code>上顺序执行。即使在<code>Objective-C</code>中的<code>if</code>和<code>for</code>等控制语句或函数调用的情况下，执行命令列的地址只是远离当前的位置，在<code>CPU</code>上执行的<code>CPU</code>命令就好比一条无分叉的大道，其执行不会出现分歧。如图所示：<br><img src="http://img.jessieedu.com/15110631212724.jpg" alt=""></p>
<p>这里所说的一个<code>CPU</code>执行的<code>CPU</code>命令列为一条无分叉路径即为“线程”。多线程即为同时有多条无分叉的执行路径。基本上一个<code>CPU</code>核一次只能执行的<code>CPU</code>命令始终为1，为了实现多线程技术，<code>iOS</code>的核心<code>XUN</code>内核在发生操作系事件时会切换执行路径，执行中路径的状态保存到各自路径专用的内存中，从切换目标路径专用的内存块中恢复<code>CPU</code>寄存器信息，继续执行切换路径的<code>CPU</code>命令列被称为“上下文切换”。由于使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，因此看上起就像一个<code>CPU</code>核能够并列的执行多个线程一样。当在具有多个<code>CPU</code>核情况下，就真的是提供了多个<code>CPU</code>核心并行执行多个线程的技术了。</p>
<p>但是，多线程编程在实际上很容易发生各种问题。例如数据竞争（多个线程同时操作数据，导致数据不一致，数据库最能体现这一状况）、死锁（停止等待事件的线程导致多个线程互相持续等待）、内存消耗过大（开启太多线程）。</p>
<h1 id="GCD中的API"><a href="#GCD中的API" class="headerlink" title="GCD中的API"></a>GCD中的API</h1><h2 id="Dispatch-Queue"><a href="#Dispatch-Queue" class="headerlink" title="Dispatch Queue"></a>Dispatch Queue</h2><p>在Apple的官方文档中，开发者需要做的事件添加到合适的Dispatch Queue中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_async(queue, ^&#123;</div><div class="line"></div><div class="line">    // 要做的事件            </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在<code>Dispatch Queue</code>中，任务遵循<code>FIFO</code>的顺序执行处理。<br><img src="http://img.jessieedu.com/15110657305490.jpg" alt=""></p>
<p>但是在执行处理时存在两种<code>Dispath Queue</code>，如表所示：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial Dispatch Queue</td>
<td>等待现在执行中处理结果</td>
</tr>
<tr>
<td>Concurrent Dispatch Queue</td>
<td>不等待现在执行的处理结果</td>
</tr>
</tbody>
</table>
<p>代码执行如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void (^block1)(void) = ^&#123;</div><div class="line">    NSLog(@&quot;block1&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void (^block2)(void) = ^&#123;</div><div class="line">    NSLog(@&quot;block2&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void (^block3)(void) = ^&#123;</div><div class="line">    NSLog(@&quot;block3&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void (^block4)(void) = ^&#123;</div><div class="line">    NSLog(@&quot;block4&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">dispatch_async(queue, block1);</div><div class="line">dispatch_async(queue, block2);</div><div class="line">dispatch_async(queue, block3);</div><div class="line">dispatch_async(queue, block4);</div></pre></td></tr></table></figure>
<ul>
<li>当 <code>queue</code> 为 <code>DISPATCH_QUEUE_SERIAL</code>模式打印结果为</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">block1</div><div class="line">block2</div><div class="line">block3</div><div class="line">block4</div></pre></td></tr></table></figure>
<ul>
<li>当 <code>queue</code> 为 <code>DISPATCH_QUEUE_CONCURRENT</code>模式打印结果为</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">block1</div><div class="line">block4</div><div class="line">block3</div><div class="line">block2</div></pre></td></tr></table></figure>
<p>当变量<code>queue</code>为<code>DISPATCH_QUEUE_SERIAL</code>时候，因为需要等待现在执行中的任务结束才能进入到下一个任务，所以会顺序执行。而<code>queue</code>为<code>DISPATCH_QUEUE_CONCURRENT</code>时，无论当前任务是否执行完毕都会进行下一个任务的处理，虽然不用等待结束处理并且可以并行执行多个任务，但执行的处理数量取决于当前的处理数量和当前系统状态。即iOS和OS X基于Dispatch Queue中的处理数、CPU核数以及CPU负荷等状态来决定并行执行的处理数。<code>DISPATCH_QUEUE_SERIAL</code>类型只在一个一个线程中执行任务，而<code>DISPATCH_QUEUE_CONCURRENT</code>类型将使用多个线程执行。但是多个<code>DISPATCH_QUEUE_SERIAL</code>类型的线程时可以并行执行的，并不公用同一个线程，如图：<br><img src="http://img.jessieedu.com/15133934969884.jpg" alt=""></p>
<p>如果大量开辟线程，正如上文讨论大到的，回造成内存的大量消耗，引起大量的上下文切换，大幅降低系统的响应性能。在数据访问过程中造成大量锁和等待的问题。</p>
<h2 id="dispatch-queue-create"><a href="#dispatch-queue-create" class="headerlink" title="dispatch_queue_create"></a>dispatch_queue_create</h2><p>创建线程的一种方式就是通过<code>GCD</code>中的<code>API</code>，生成<code>Serial Dispatch Queue</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.chen.test&quot;, DISPATCH_QUEUE_SERIAL);</div></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.chen.test&quot;,NULL);</div></pre></td></tr></table></figure>
<p>其中<code>com.chen.test</code>参数是线程的一个描述或者叫做线程名，方便在后期的调试或者<code>Crash</code>信息中获取到当前的线程信息，可以为<code>NULL</code>。</p>
<p>通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.chen.test&quot;, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<p><del>创建一个<code>Concurrent Dispatch</code>类型的<code>Queue</code>。另外由于<code>Dispatch Queue</code>并没有在编译的时候加入引用计数的处理，创建的<code>queue</code>需要自己你去释放或持有</del></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dispatch_retain(queue);</div><div class="line">dispatch_release(queue);</div></pre></td></tr></table></figure>
<p><del>即<code>Dispatch Queue</code>也像<code>Objective-C</code>的引用计数式内存管理一样需要<code>dispatch_retain</code>和<code>dispatch_release</code>函数的引用计数来管理内存。假如创建一个函数并追加一个任务并马上释放该线程会不会出现问题那？并不会，在<code>dispatch_async</code>函数中追加<code>Blok</code>到<code>Queue</code>中，此时，相当于<code>Block</code>持有该<code>queue</code>，而<code>queue</code>持有一个<code>Block</code>，相互引用。当<code>Block</code>执行完毕，<code>queue</code>释放<code>Block</code>相互引用链断开，<code>queue</code>也被释放。</del><br>以上接口在<code>iOS6</code>中被禁用，从<code>iOS6</code>开始，<code>GCD</code>也被<code>ARC</code>所管理。</p>
<h2 id="Main-Dispatch-Queue-Global-Dispatch-Queue"><a href="#Main-Dispatch-Queue-Global-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue/Global Dispatch Queue"></a>Main Dispatch Queue/Global Dispatch Queue</h2><p>使用多线程第二种方式就是获取系统提供的<code>Dispatch Queue</code>。由于主线程只有一个，所以<code>Main Dispatch Queue</code>自然就是<code>Serial Dispatch Queue</code>。<code>Global Dispatc号Queue</code>为全局可用的<code>Concurrent Dispatch queue</code>，有4个优先级，分别如下:</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>iOS8之后</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>DISPATCH_QUEUE_PRIORITY_HIGH</td>
<td>QOS_CLASS_USER_INTERACTIVE</td>
<td>高</td>
</tr>
<tr>
<td>DISPATCH_QUEUE_PRIORITY_DEFAULT</td>
<td>QOS_CLASS_DEFAULT</td>
<td>默认</td>
</tr>
<tr>
<td>DISPATCH_QUEUE_PRIORITY_LOW</td>
<td>QOS_CLASS_UTILITY</td>
<td>低</td>
</tr>
<tr>
<td>DISPATCH_QUEUE_PRIORITY_BACKGROUND</td>
<td>QOS_CLASS_BACKGROUND</td>
<td>后台</td>
</tr>
</tbody>
</table>
<h2 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h2><p>使用<code>dispatch_queue_create</code> 函数生成的<code>Dispatch Queue</code>默认是使用的<code>Global Dispatch Queue</code>相同的优先级，而<code>dispatch_set_target_queue</code>函数用来变更优先级：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t globleQueue = dispatch_queue_create(&quot;com.abner.test&quot;, NULL);</div><div class="line">        </div><div class="line">dispatch_queue_t backgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);</div><div class="line">        </div><div class="line">dispatch_set_target_queue(globleQueue, backgroundQueue);</div></pre></td></tr></table></figure>
<p>指定要变更执行优先级的Queue为<code>dispatch_set_target_queue</code>函数的第一个参数，指定要与要使用的执行优先级相同优先级的<code>Queue</code>为第二个参数。前提是第一个参数不是系统提供的<code>Main Queue</code>或<code>Globle Dispatch Queue</code>。否则将出现不可预知的情况。</p>
<h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">           NSLog(@&quot;addTask&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>dispatch_after</code>在指定时间之后将任务通过<code>dispatch_async</code>函数添加到<code>Dispatch Queue</code>中，在<code>Main Queue</code>中的<code>RunLoop</code>执行中，是每经过<code>1/60</code>秒刷新一下，即在追加到线程之后的任务最快在<code>3</code>秒之后执行，最慢在<code>3+1/60</code>秒执行， 在时间延迟要求不高的地方使用是个便捷有效的方法。</p>
<h2 id="Dispath-Group"><a href="#Dispath-Group" class="headerlink" title="Dispath Group"></a>Dispath Group</h2><p>现在有这样一个需求：</p>
<blockquote>
<p>有一张大图（10MB），如果一个线程请求比较慢，现在将这张图片切割成5份，大约每个片段为2MB，然后在下载完毕之后将5个片段组合成一个文件，展示给用户.</p>
</blockquote>
<p>此处如果使用<code>Serial Dispatch Queue</code>只需将下载任务按顺序添加，最后添加结束任务即可，但是这样违背了需求初衷，无法并列下载。但是使用<code>Concurrent Dispatch Queue</code>实现就显得很复杂。在这里就用到了<code>Dispath Group</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">        </div><div class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;模块1&quot;); &#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;模块2&quot;); &#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;模块3&quot;); &#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;模块4&quot;); &#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;模块5&quot;); &#125;);</div><div class="line">        </div><div class="line">dispatch_group_notify(group, queue, ^&#123;NSLog(@&quot;finish&quot;); &#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">模块4</div><div class="line">模块5</div><div class="line">模块2</div><div class="line">模块1</div><div class="line">模块3</div><div class="line">finish</div></pre></td></tr></table></figure>
<p>在<code>Dispatch Group</code>中也可以使用<code>dispatch_group_wait</code>函数仅等待全部任务执行结束止再往下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div></pre></td></tr></table></figure>
<p>第二个参数为<code>dispatch_time_t</code>类型的值，只要<code>Group</code>中的任务没有执行结束，就一直等待，中途无法取消。当返回值为0的时候，表明经过特定时间后全部任务执行完毕。这里的“等待”意味着一旦调用该函数，该函数就处于调用而不返回的状态。即，使当前的线程停止，经过指定时间或任务结束之后停止。造成一种卡死的假象。</p>
<h2 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch_sync"></a>dispatch_sync</h2><p><code>dispatch_async</code>函数意味着“非同步”,即将指定的<code>Block</code>“非同步”的追加到指定的<code>Dispatch Queue</code>中，<code>dispatch_async</code>函数不做任何等待，原理如图：<br><img src="http://img.jessieedu.com/15136914746503.jpg" alt=""></p>
<p>而<code>dispatch_sync</code>函数在指定的处理执行结束之前，该函数不会返回。即<code>dispatch_group_wait</code>函数的简写版。在使用中应特别注意，容易引起死锁的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class="line">           </div><div class="line">    NSLog(@&quot;block&quot;);</div><div class="line">&#125;);</div><div class="line">        </div><div class="line">NSLog(@&quot;finish&quot;);</div></pre></td></tr></table></figure>
<p>该代码在<code>Main Dispatch Queue</code>中要执行指定的<code>Block</code>,并等待其执行结束。而其实在主线程中正在执行这些源代码，所以无法执行追加到<code>Main Dispatch Queue</code>的<code>Block</code>。</p>
<h2 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h2><p>在访问数据库或者文件的时候，使用<code>Serial Dispatch Queue</code>可以避免数据竞争的问题，在并发处理中，如果读取任务只是与读取任务并行处理多个线程并行就不会出现问题。为了高校的进行访问，将读取任务追加到<code>Concurrent Dispatch Queue</code>中，写入处理在任一个读取没有执行的状况下，追加到<code>Serial Dispatch Queue</code>中即可，即在写入处理结束之前，读取处理不可操作。<code>dispatch_barrier_async</code>函数则实现了该功能。如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_async(queue, read1Block);</div><div class="line">dispatch_async(queue, read2Block&#125;);</div><div class="line">dispatch_async(queue, read2Block&#125;);</div><div class="line">dispatch_async(queue, read2Block&#125;);</div><div class="line">dispatch_barrier_async(queue, writingBlock);</div><div class="line">dispatch_async(queue, read2Block);</div><div class="line">dispatch_async(queue, read2Block);</div><div class="line">dispatch_async(queue, read2Block);</div></pre></td></tr></table></figure>
<p>执行顺序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">read2</div><div class="line">read1</div><div class="line">read3</div><div class="line">read4</div><div class="line">writing</div><div class="line">read6</div><div class="line">read5</div><div class="line">read7</div></pre></td></tr></table></figure>
<p>使用<code>dispatch_barrier_async</code>函数会扽带追加到<code>Concurrent Dispatch Queue</code>上的并行任务处理全部结束之后再将指定的处理追加到该<code>Concurrent Dispatch Queue</code>中，然后在由<code>dispatch_barrier_async</code>函数追加的任务执行完毕后<code>Concurrent Dispatch Queue</code>才恢复为一般的动作，此时该线程中的任务恢复并行处理。在这里存在<code>dispatch_barrier_async</code>函数才想就会存在<code>dispatch_barrier_sync</code>函数。二者的区别就是前者不会等待自己的任执行完毕就接着执行下面的任务，而后者需要等到自己的任务执行完毕再执行后面添加的任务。</p>
<h2 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h2><p><code>dispatch_apply</code>函数是<code>dispatch_sync</code>函数和<code>Dispatch Group</code>的关联<code>API</code>，该函数按照指定的次数将指定的<code>Block</code>追加到指定的<code>Dispatch Queue</code>中，并等待全部执行结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSArray *contentArray = @[@&quot;A&quot;, @&quot;B&quot;, @&quot;C&quot;, @&quot;D&quot;, @&quot;E&quot;];</div><div class="line">    </div><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">    </div><div class="line">dispatch_apply(contentArray.count, queue, ^(size_t idx) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;, contentArray[idx]);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;finish&quot;);</div></pre></td></tr></table></figure>
<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">D</div><div class="line">A</div><div class="line">B</div><div class="line">C</div><div class="line">E</div><div class="line">finish</div></pre></td></tr></table></figure>
<p>该方法起到一个遍历的作用，同时支持删除<code>contentArray</code>中的元素。</p>
<h2 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend / dispatch_resume"></a>dispatch_suspend / dispatch_resume</h2><p>顾名思义，<code>dispatch_suspend</code>是暂停一个线程，而<code>dispatch_resume</code>是恢复一个线程。使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 暂停</div><div class="line">dispatch_suspend(queue);</div><div class="line">   </div><div class="line">// 恢复继续</div><div class="line">dispatch_resume(queue);</div></pre></td></tr></table></figure>
<h2 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h2><p>在并行执行的处理更新数据时候，会造成内存异常导致程序异常退出，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">    </div><div class="line">NSMutableArray *conten = [NSMutableArray arrayWithCapacity:1000000];</div><div class="line">for(NSInteger i = 0; i &lt; 1000000000; i++)&#123;</div><div class="line">        </div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">        [conten addObject:@(i)];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Dispatch Semaphore</code>是持有计数的信号，该计数是多线程中的计数类型信号。使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 创建</div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</div><div class="line">// 等待信号量</div><div class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">// 发送一个信号量</div><div class="line">dispatch_semaphore_signal(semaphore);</div></pre></td></tr></table></figure>
<p>具体应用场景举例：有一个可以容纳3个车的停车场，<code>dispatch_semaphore_create(3)</code>函数就代表创建这个停车场。<code>dispatch_semaphore_wait()</code>函数表示等待，如果内部已经有三辆车，后面的车将无法进入。即<code>wait</code>后面的任务将不再执行。当停车场内部的车辆为小于三辆车时，其他车辆才能进入。使用举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(5);</div><div class="line">dispatch_queue_t queue =    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">for (int i = 0; i &lt; 20; i++)</div><div class="line">&#123;</div><div class="line">    NSInteger res = dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">    dispatch_group_async(group, queue, ^&#123;</div><div class="line">        NSLog(@&quot;async - %d&quot;,i);</div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">        sleep(2);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div></pre></td></tr></table></figure>
<p>创建一个能容纳5辆车的停车场，此时一共有20辆车，每进入一辆车调用一下<code>dispatch_semaphore_signal()</code>函数，计数加一，当停车场内部的车辆出去一辆的时候计数减少1，通过<code>dispatch_semaphore_wait()</code>函数特定时间监测当前计数是否小于5，当小于5的时候其他车辆才能进入。</p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> GCD </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Xcode模拟器无法联网问题的解决]]></title>
      <url>/2015/10/15/XcodeSimulatorNetError/</url>
      <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>今天在使用Xcode调试的时候发现不能够连接到服务器了，数据返回的<code>code</code>为<code>502</code>。<br>开始使用的时候以为是断网了但实际发现Mac是可以连接网络的。然后更换另一个项目另一个项目也无法连接到服务器。所以怀疑是项目服务器出了问题（公司所有的开发接口均为内网地址），但同事的却都可以连接到服务器。并且，我打开模拟器带的Safir的时候发现什么也打不开了。这说明我这里网络出现了问题。</p>
<h1 id="解决方法一"><a href="#解决方法一" class="headerlink" title="解决方法一"></a>解决方法一</h1><p>关闭模拟器，重新运行项目，无法联网，方法失败。</p>
<p>复位模拟器，重新运行项目，无法联网，方法失败。</p>
<p>重启Mac，重新运行项目，无法联网，方法失败。</p>
<h1 id="解决方法二"><a href="#解决方法二" class="headerlink" title="解决方法二"></a>解决方法二</h1><p>换一个思路，既然是网络出现的问题，就查看网络设置。<br>打开 <code>网络便好设置</code>,<code>ip</code> 和 <code>DNS</code> 都没问题,查看代理的时候出现了问题，如图:</p>
<p><img src="http://img.jessieedu.com/Snip20160907_3.png" alt=""></p>
<p>将选中的两项选勾掉，再次运行，成功连接服务器！</p>
<p>分析的得知，由于工作需要，在本地配置了<code>XX-Net</code>代理软件(决非广告)，在配置属性的时候，选择了全局代理：</p>
<p><img src="http://img.jessieedu.com/Snip20160907_6.png" alt=""></p>
<p>然后将属性改为自动代理以后网络的设置：</p>
<p><img src="http://img.jessieedu.com/Snip20160907_7.png" alt=""></p>
<p>再次运行项目，联网正常！</p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 模拟器 </tag>
            
            <tag> 联网失败 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[个人搭建博客经历]]></title>
      <url>/2015/09/19/PersonFirst/</url>
      <content type="html"><![CDATA[<p>个人搭建的第一个博客终于算是成型了，总体感受还是比较简单的，而且体验也不错。</p>
<p>之前考虑过使用<code>Wordpress</code>来建站。经过考察感觉没有太大的必要，要使用<code>Wordpress</code>来建站的话，需要有自己的空间，而且需要<code>Apache</code>+<code>MySQL</code>+<code>PHP</code>。在阿里云上使用<code>XAMPP</code>已经搭建了一套服务，但是那个只是自己搞的一个测试服务器。在没有指导的情况下经常将服务器搞瘫痪。所以稳妥一点，借助<code>GitHub Pages</code>的平台最一个稳定的<code>Blog</code>吧。另外，现在有大量的<code>Blog</code>网站网站都有着不错的体验，但是和<code>Pages</code>相比又缺少一些自由。</p>
<p>搭建<code>GitHub Pages</code>并不难，网上很多教程，这里给出一个<a href="http://www.jianshu.com/p/f66103553c45" target="_blank" rel="external">教程</a>。</p>
<p>这里说一下我遇到的几个问题：</p>
<ol>
<li>搭建完毕后点击<code>分类</code>和<code>关于</code>会进入<code>404</code>页面。此处建议在跟目录上放一个自定义的<code>404</code>页面。命名为：<code>404.html</code>。</li>
<li><p>分类页面不会自动生成。需要自己创建：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new page categories</div></pre></td></tr></table></figure>
<p> 然后进入到<code>Hexo/source/categories/</code>，在<code>index.md</code>中添加以下信息：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: categories</div><div class="line">type: &quot;categories&quot;</div><div class="line">comments: false</div><div class="line">---</div></pre></td></tr></table></figure>
<p> 同理创建关于界面：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new page about</div></pre></td></tr></table></figure>
</li>
<li><p>每次写完<code>Blog</code>，都需要一系列的操作。创建一个脚本文件，一个操作实现发布：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo generate</div><div class="line">cp -R public/* .deploy/xxx.github.io</div><div class="line">cd .deploy/xxx.github.io</div><div class="line"></div><div class="line">git add .</div><div class="line">git commit -m &quot;update&quot; </div><div class="line">git push   origin master</div></pre></td></tr></table></figure>
<p> 上面的<code>xxx.github.io</code>填写自己的<code>Pages</code>地址。 </p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[categories]]></title>
      <url>/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于]]></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>Email：<a href="mailto:cw_028@163.com／" target="_blank" rel="external">@cw_028@163.com</a></p>
<p>GitHub：<a href="https://github.com/AbnerChen028/" target="_blank" rel="external">@AbnerChen028</a></p>
]]></content>
    </entry>
    
  
</search>
